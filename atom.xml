<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kibo</title>
  
  <subtitle>Everything is for the future.</subtitle>
  <link href="http://voidbean.top/atom.xml" rel="self"/>
  
  <link href="http://voidbean.top/"/>
  <updated>2025-02-07T08:08:24.713Z</updated>
  <id>http://voidbean.top/</id>
  
  <author>
    <name>VoidBean</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://voidbean.top/2025/02/07/MVN%20Error/"/>
    <id>http://voidbean.top/2025/02/07/MVN%20Error/</id>
    <published>2025-02-07T08:01:50.798Z</published>
    <updated>2025-02-07T08:08:24.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVN同级项目无法找到的问题修复"><a href="#MVN同级项目无法找到的问题修复" class="headerlink" title="MVN同级项目无法找到的问题修复"></a>MVN同级项目无法找到的问题修复</h2><p>最近的一个老项目调整了pom结构，部分依赖归到上层parent中了，公共工具包还放在子项目的ad-common中，结果导致构建的时候package失败。旧的build脚本核心方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function build()&#123;</span><br><span class="line">    Log INFO &quot;Start $&#123;COMPONENT_NAME&#125; component build ...&quot;</span><br><span class="line">    Log INFO &quot;cd ad-common &amp;&amp; mvn clean install -Dmaven.test.skip=true&quot;</span><br><span class="line">    cd ad-common</span><br><span class="line">    mvn -U clean install -Dmaven.test.skip=true</span><br><span class="line">    isError</span><br><span class="line">    cd -</span><br><span class="line"></span><br><span class="line">    Log INFO &quot;cd ad-server &amp;&amp; mvn clean package -Dmaven.test.skip=true&quot;</span><br><span class="line">    cd ad-server</span><br><span class="line">    mvn clean package -Dmaven.test.skip=true</span><br><span class="line">    isError</span><br><span class="line">    cd -</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到ad-server的package阶段的时候，会出现找不到本地ad-common的包而导致转向云端仓库检索，最后因为获取不到导致部署失败。</p><p>开始我以为是pom中的配置有疏漏，结果仔细排查后发现无论mvn仓库中ad-common的位置没有问题，同时install的日志也没有异常情况。于是我在package阶段的日志加了-X来观察debug日志。</p><p>发现在进行package时，日志抛出了一行警告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not find metadata com.test:ad:0.0.1-SNAPSHOT/maven-metadata.xml in local (/Users/beanalter/apache-maven-3.6.1/maven_repo)</span><br></pre></td></tr></table></figure><p>可以看到这里提示的找不到的路径并不是ad-common，而是父层的metadata，所以我重新调整了脚本，让build时先install父层的pom，再install ad-common，最后再执行package，果然问题解决。脚本修改后如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function build()&#123;</span><br><span class="line">    Log INFO &quot;Start $&#123;COMPONENT_NAME&#125; component build ...&quot;</span><br><span class="line"></span><br><span class="line">    Log INFO &quot; mvn clean install -Dmaven.test.skip=true -N&quot;</span><br><span class="line">    mvn -U clean install -Dmaven.test.skip=true -N</span><br><span class="line"></span><br><span class="line">    Log INFO &quot;cd ad-common &amp;&amp; mvn clean install -Dmaven.test.skip=true&quot;</span><br><span class="line">    cd ad-common</span><br><span class="line">    mvn -U clean install -Dmaven.test.skip=true</span><br><span class="line">    isError</span><br><span class="line">    cd -</span><br><span class="line"></span><br><span class="line">    Log INFO &quot;cd ad-server &amp;&amp; mvn clean package -Dmaven.test.skip=true&quot;</span><br><span class="line">    cd ad-server</span><br><span class="line">    mvn clean package -Dmaven.test.skip=true</span><br><span class="line">    isError</span><br><span class="line">    cd -</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MVN同级项目无法找到的问题修复&quot;&gt;&lt;a href=&quot;#MVN同级项目无法找到的问题修复&quot; class=&quot;headerlink&quot; title=&quot;MVN同级项目无法找到的问题修复&quot;&gt;&lt;/a&gt;MVN同级项目无法找到的问题修复&lt;/h2&gt;&lt;p&gt;最近的一个老项目调整了pom</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Amazon SQS调研</title>
    <link href="http://voidbean.top/2022/01/30/Aws%20SQS/"/>
    <id>http://voidbean.top/2022/01/30/Aws%20SQS/</id>
    <published>2022-01-30T03:06:17.000Z</published>
    <updated>2022-01-30T03:08:21.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Amazon-SQS-的特性"><a href="#Amazon-SQS-的特性" class="headerlink" title="Amazon SQS 的特性"></a>Amazon SQS 的特性</h2><p><strong>Simple Queue Service</strong></p><ul><li><strong>安全性</strong>–支持<a href="https://docs.aws.amazon.com/zh_cn/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-authentication-and-access-control.html">IAM</a>来控制谁能向 Amazon SQS 队列发送消息以及谁能从队列接收消息。在IAM中, 用户可以随时自定义一组角色来对权限进行管控, 设置完成后可以获得一组指定的awsAccessKeyId与awsSecretKey来决定请求的权限, 这两个属性值可以从运行时参数, 环境变量, 密钥文件, 代码指定来配置.</li></ul><blockquote><p>awsAccessKeyId与awsSecretKey在生成后就无法更改, 可以理解为生成一组用户名和密码, 同时密码仅初次生成时可见. 生成后会得到一份密钥文件, 该文件也可以用于使用Amazon SDK时的认证</p></blockquote><p><img src="/pic/image-20210924151625807.png" alt="image-20210924151625807"></p><ul><li><strong>持久性</strong>— 为确保消息安全，Amazon SQS 将消息存储在多个服务器上。目前支持两种队列, 分别为支持至少一次消息传递的标准队列和 支持完全一次的消息处理的FIFO ( 先进先出 ) 队列</li></ul><blockquote><p>先进先出可以保证队列内消息的顺序按照发送的顺序保持一致, 消费者获得的消息会严格按照生产者传入sqs的时间顺序</p><p>完全一次的消息处理则是通过重复数据删除的方式, 保证<code>SendMessage</code>不会引入重复数据</p><p> 具体细节会在下文讲解</p></blockquote><ul><li><strong>可用性</strong>— Amazon SQS 使用<a href="https://docs.aws.amazon.com/zh_cn/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-basic-architecture.html">冗余基础设施</a>为生成和使用消息提供高度并发的消息访问和高可用性。</li></ul><blockquote><p>队列的消息会通过冗余存储的方式存在于多台Amazon的服务器中, 由于此部分由Amazon负责, 所以无需在部署层面对此进行考量</p></blockquote><ul><li><strong>可扩展性</strong>— 通过AWS的JAVA SDK, 可以通过批处理与水平扩展来提高吞吐量, 可透明扩展以处理任何负载增加或峰值，无需任何预配置指令。</li></ul><blockquote><p>客户端缓冲允许将10个请求合并为1个请求后再发送至SQS, 该功能仅支持普通队列, 不支持FIFO队列</p></blockquote><ul><li><strong>可靠性</strong>Amazon SQS 在处理期间锁定消息，以便多个生成者可同时发送消息，多个消费者可同时接收消息。</li><li><strong>自定义</strong>— 支持多个队列的自定义配置, 如可为每个队列设置不同的可见性超时 | 消息保留时间 | 交付延迟 | 接收消息的等待时间. 也可存储大于 256 KB 的消息的内容</li></ul><blockquote><p>对于超过256KB的消息, 需要使用<a href="https://docs.aws.amazon.com/zh_cn/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-s3-messages.html">Amazon Simple Storage Service (Amazon S3)</a>或Amazon DynamoDB，让Amazon SQS 持有指向 Amazon S3 对象的指针, 也可以将一个大消息拆分为几个小消息。</p></blockquote><h2 id="横向对比"><a href="#横向对比" class="headerlink" title="横向对比"></a>横向对比</h2><table><thead><tr><th></th><th>Kafka</th><th>RabbitMQ</th><th>SQS</th></tr></thead><tbody><tr><td>本地部署</td><td>√</td><td>√</td><td>×</td></tr><tr><td>第一方部署</td><td>×</td><td>×</td><td>√</td></tr><tr><td>第三方部署</td><td>√</td><td>√</td><td>×</td></tr><tr><td>复杂的路由逻辑</td><td>×</td><td>√</td><td>√</td></tr><tr><td>海量数据</td><td>√</td><td>×</td><td>×</td></tr><tr><td>简易部署</td><td>×</td><td>×</td><td>√</td></tr></tbody></table><p>相比于其他的MQ, SQS优点在于第一方的简易部署, 无需担心集群, 存储空间等问题, 但随之带来的也有费用成本问题, SQS的费用会按照访问次数进行计费. SQS还对消息大小有限制, 如果要传输超过256KB的消息, 则需要Amazon S3的支持.</p><h2 id="Amazon-SQS-的原理"><a href="#Amazon-SQS-的原理" class="headerlink" title="Amazon SQS 的原理"></a>Amazon SQS 的原理</h2><p>由于普通队列大致上与常见MQ一致, 下文仅以FIFO队列为例介绍原理, 部分功能仅支持普通度列或FIFO队列时会单独予以说明</p><blockquote><p>如果需要实现广播消息传递的方式, 则需要搭配Amazon SNS</p></blockquote><h3 id="FIFO-先进先出队列原理及特性"><a href="#FIFO-先进先出队列原理及特性" class="headerlink" title="FIFO 先进先出队列原理及特性"></a>FIFO 先进先出队列原理及特性</h3><p><strong>发送消息</strong></p><p>如果多条消息连续发送到 FIFO 队列（每条消息具有不同的消息重复数据删除 ID），Amazon SQS 将存储消息并确认传输。然后按传输每条消息的确切顺序接收和处理消息。</p><p>在 FIFO 队列中，消息基于消息组 ID 进行排序 ( 同组内消息会进行严格排序 )。如果多个应用将具有相同消息组 ID 的消息发送到 FIFO 队列，Amazon SQS 将按消息到达的先后顺序进行消息存储。</p><p>FIFO 队列逻辑仅应用于每个消息组 ID。每个消息组 ID 代表 Amazon SQS 队列中不同的有序的消息组。对于每一个消息组 ID，所有消息的发送和接收均严格遵循一定的顺序。但是，具有不同的消息组 ID 值的消息可能不会按顺序发送和接收 ( 下文会有实例 ) 。如果需要一组有序的消息，需要在将消息发送到 FIFO 队列前指定相同的消息组 ID。</p><p><strong>接收消息</strong></p><p>消费者接收消息时无法指定接收的消息组ID, 在指定队列名称后就会直接通过SQS来获取消息。</p><p>当接收来自具有多个消息组 ID 的 FIFO 队列的消息时，Amazon SQS 会首先尝试尽可能多地返回具有相同消息组 ID 的消息。同时该组内的消息会严格按照时间顺序接收.</p><p>范例如下, 顺序发送消息hello1~6, 其中1,4,5的groupId为Default, 2,3的groupId为ack, 6的groupId为acks, 则在接受消息时, 同组消息严格按照先进先出的顺序进行获取, 但对于不同组的数据, 其接受顺序则无法确定</p><p>对于多个应用同时获取消息, 且消息有多组时, SQS会尽可能的将同一组消息发送给同一个应用</p><p><img src="/pic/image-20210918114514973.png" alt="image-20210918114514973"></p><p><strong>多次重试</strong></p><p>FIFO 队列允许生产者或消费者尝试多次重试：</p><ul><li>如果生产者检测到失败<code>SendMessage</code>操作时，它可以使用相同的消息重复数据消除 ID，可以根据具体情况, 设置重试发送n次。由于有重复删除ID这一属性的存在, 无需担心重复数据存放于SQS中.</li><li>如果消费者检测到失败<code>ReceiveMessage</code>操作，它同样也可以根据需要重试次数，使用相同的接收请求尝试 ID ( 创建请求时会自动生成一个请求尝试ID )。如果在可见性超时到期之前至少收到一个确认，多次重试也不会影响消息的排序。</li><li>消费者收到一条带有消息组ID的消息时，除非删除该消息或该消息变为可见，否则不会返回同一消息组 ID 的其他消息。</li></ul><p>在启用<strong>基于内容的重复数据删除</strong>时, 如果没有显式的指定重复删除id, 则会自动根据消息内容, 使用SHA-256 hash值作为重复删除id</p><p>如果没有启用<strong>基于内容的重复数据删除</strong>, 则需要每次发送消息时在消息属性中加入<code>JMS_SQS_DeduplicationId</code>指定判定重复删除的ID</p><p><img src="/pic/image-20210918121153511.png" alt="image-20210918121153511"></p><p>在重试方面, 如果开启自动生成重复数据删除ID了, 那么生产者无需考虑该项的生成, 在出现失败的<code>SendMessage</code>时可以直接进行重试操作. 对于消费者而言, 官方建议在请求时使用请求尝试 ID, 以便在 <code>ReceiveMessage</code>失败时可以快速进行重试</p><blockquote><blockquote><p>虽然有重试机制, 但SQS并不能完全保证每条消息只有一个消费者消费, 消费者仍需要实现幂等</p></blockquote><blockquote><p>生产者的重复数据消除ID自身有间隔时间 ( 默认5min ), 在超出该时间后, 如果仍在执行重试, 则可能会出现重复数据进入队列中</p></blockquote><blockquote><p>消费者在消费消息时会有可见性超时的设置, 在超时后其他消费者便会开始处理该消息, 如果需要避免这种情况则需要创建死信队列</p></blockquote></blockquote><p><strong>消息存储</strong></p><p>FIFO队列的消息存储是根据消息组ID的hash值来决定存储消息想分区, 同组的存储顺序与添加到队列的顺序相同</p><p>在使用批处理API的情况下, 每个分区每秒最多 3000 条，即无批处理的情况下每秒支持 300 条消息用于发送、接收和删除操作</p><p>如果为FIFO队列开启了高吞吐量, 则在批处理的情况下每个分区可达到30,000次处理</p><blockquote><p>Amazon SQS 经过优化，不论 FIFO 队列的分区数如何，都可在这些分区上统一分配item。官方建议使用非重复值的消息组 ID</p></blockquote><p><strong>消息接收方式</strong></p><p>SQS的消息接收通过轮询方式, 支持长短轮询,</p><p>短轮询时, 查询后无论有无数据都会立即返回结果; 而长轮询会在SQS中至少包含有一条数据的情况下才会返回响应结果, 但如果超过了长轮训最长等待时间后仍无数据时, 长轮询也会返回空的响应结果</p><blockquote><p>官方建议使用长轮询, 同时使用长轮询也可以减低SQS的使用成本 ( 长短轮询的费用是一致的 ) </p></blockquote><p><strong>死信队列处理</strong></p><p>在出现消息失败时, 可以将失败消息转入预置的死信队列中来处理异常, 死信队列可以执行如下操作:</p><ul><li>为传输到死信队列的任何消息配置警报。</li><li>查看日志以了解可能导致消息传输到死信队列的异常。</li><li>分析传输到死信队列的消息的内容，以诊断软件问题或创建器&#x2F;使用器的硬件问题。</li><li>确定是否为使用者提供了充足的时间来处理消息。</li></ul><p>由于普通队列和FIFO队列这两种不同的队列类型的存在, 则需要创建的DLQ的类型与普通|FIFO队列类型保持一致, 创建死信队列后, 便可以为任意队列指定对应的死信队列, 同时还需要设置转入死信队列的阈值, 如果消息的<strong>ReceiveCount</strong>超过了队列的最大接收计数, Amazon SQS 会将消息移至（与其原始消息 ID）关联的 DLQ. 在配置时, <strong>最大接收</strong> 值决定了消息何时发送到 DLQ。如果消息的<strong>ReceiveCount</strong>超过了队列的最大接收计数， Amazon SQS 会将消息移至（与其原始消息 ID）关联的 DLQ</p><p>对死信队列, 还可以配置aws lambda, 当DLQ接受到失败消息时, 可根据具体的业务需求执行对应的lambda函数来实现后续如报警之类的操作.</p><p><img src="/pic/image-20210924111347570.png" alt="image-20210924111347570"></p><p>在对应的Lambda可以执行预先定义好的方法, 然后对消息进行处理, 处理之后的数据可以继续调用其他lanmbda函数|SQS|SNS</p><p><img src="/pic/image-20210924111749440.png" alt="image-20210924111749440"></p><p><strong>可见性超时</strong></p><p>用于消费者处理消息超时后, 将消息重新提供给其他消费者</p><blockquote><p>官方建议为获得最佳性能，应将可见性超时设置为大于 AWS SDK 读取超时的时间</p></blockquote><p><img src="/pic/image-20210924140545727.png" alt="image-20210924140545727"></p><p><strong>延迟队列</strong></p><p>延迟队列用于将新消息的传递推迟n秒, 其功能类似于可见性超时, 可用于定时推送指定消息或消费者需要更多时间去处理消息的状态. 如果对正在使用的队列, 直接修改为延迟队列 ( 即修改交付延迟 ), 则对于普通队列和FIFO队列有不同的效果:</p><ul><li>对于普通队列: 由于每个队列的延迟设置不可追溯；更改设置不会影响队列中已有消息的延迟.</li><li>对于FIFO队列: 由于每个队列延迟设置是可追溯的；更改设置会影响队列中已有消息的延迟.</li></ul><p><img src="/pic/image-20210924140545727.png" alt="image-20210924140545727"></p><h2 id="JAVA-SDK使用实践"><a href="#JAVA-SDK使用实践" class="headerlink" title="JAVA SDK使用实践"></a>JAVA SDK使用实践</h2><h3 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.amazonaws<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amazon-sqs-java-messaging-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConnectionFactory用于创建SQS的connection</span></span><br><span class="line"><span class="function">SQSConnectionFactory <span class="title">sqsConnectionFactory</span><span class="params">(String awsAccessKeyId, String awsSecretKey)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果没有指定BasicAWSCredentials, 会按照 环境变量 Environment -&gt; Java系统属性 SystemProperties -&gt; 默认文件: ~/.aws/credentials 的顺序进行写入</span></span><br><span class="line">        BasicAWSCredentials basicAWSCredentials = <span class="keyword">new</span> BasicAWSCredentials(awsAccessKeyId, awsSecretKey);</span><br><span class="line">        AWSStaticCredentialsProvider awsStaticCredentialsProvider = <span class="keyword">new</span> AWSStaticCredentialsProvider(basicAWSCredentials);</span><br><span class="line">        SQSConnectionFactory connectionFactory = <span class="keyword">new</span> SQSConnectionFactory(</span><br><span class="line">                <span class="keyword">new</span> ProviderConfiguration(),</span><br><span class="line">          <span class="comment">//Region如果不指定则会根据当前请求发送的地区自动匹配最近region</span></span><br><span class="line">                AmazonSQSClientBuilder.standard().withRegion(<span class="string">&quot;us-east-2&quot;</span>).withCredentials(awsStaticCredentialsProvider)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>具体权限凭证提供顺序参考: <a href="https://docs.aws.amazon.com/zh_cn/sdk-for-java/v1/developer-guide/credentials.html">https://docs.aws.amazon.com/zh_cn/sdk-for-java/v1/developer-guide/credentials.html</a></p></blockquote><p>在factory创建完毕后, 即可创建connection以及对应的sqsClient和session, 这里以发送消息为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SQSConnection sqsConnection = sqsConnectionFactory.createConnection();</span><br><span class="line">    AmazonSQS sqsClient = sqsConnection.getAmazonSQSClient();</span><br><span class="line"><span class="comment">//sqsClient可以用于队列的增删改查, 无法直接用于对队列数据的操作</span></span><br><span class="line">log.info(<span class="string">&quot;list queues&quot;</span>, sqsClient.listQueues());</span><br><span class="line">    <span class="comment">//如果需要对队列内数据进行操作, 需要创建session</span></span><br><span class="line">    sqsConnection.start();</span><br><span class="line">    Session session = sqsConnection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//指定队列的名称</span></span><br><span class="line">    Queue queue = session.createQueue(<span class="string">&quot;YeahmobiFIFOWork.fifo&quot;</span>);</span><br><span class="line">    <span class="comment">//如果要创建消息, 则此处需要进行消息内容的指定</span></span><br><span class="line">    TextMessage message = session.createTextMessage(<span class="string">&quot;my-test&quot;</span>);</span><br><span class="line"><span class="comment">//指定消息组ID</span></span><br><span class="line">    message.setStringProperty(<span class="string">&quot;JMSXGroupID&quot;</span>, <span class="string">&quot;Default&quot;</span>);</span><br><span class="line"><span class="comment">//指定重复数据删除ID, 该属性仅针对FIFO, 如果FIFO队列的设置中没有开启自动生成重复数据删除ID的话, 则该属性为必填项</span></span><br><span class="line">    message.setStringProperty(<span class="string">&quot;JMS_SQS_DeduplicationId&quot;</span>, <span class="string">&quot;duplicate-id-v2&quot;</span>);</span><br><span class="line">    <span class="comment">//创建生产者并进行消息发送</span></span><br><span class="line">    session.createProducer(queue).send(message);</span><br><span class="line">    sqsConnection.close();</span><br></pre></td></tr></table></figure><p>如果要接收消息, 在创建session后进行如下操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上文创建过程</span></span><br><span class="line">    SQSConnection sqsConnection = sqsConnectionFactory.createConnection();</span><br><span class="line">    sqsConnection.start();</span><br><span class="line">    Session session = sqsConnection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">    Queue queue = session.createQueue(<span class="string">&quot;YeahmobiFIFOWork.fifo&quot;</span>);</span><br><span class="line"><span class="comment">//创建消费者, 对消息进行消费</span></span><br><span class="line">Message message = session.createConsumer(queue).receive();</span><br><span class="line">    TextMessage textMessage = ((TextMessage)message);</span><br><span class="line">    log.info(<span class="string">&quot;query message:&#123;&#125;, groupId:&#123;&#125;&quot;</span>,textMessage.getText(),textMessage.getStringProperty(<span class="string">&quot;JMSXGroupID&quot;</span>));</span><br><span class="line">sqsConnection.close();</span><br></pre></td></tr></table></figure><p>如果需要监听消息, 则需要实现<code>MessageListener</code>, 并在创建消费者时将其该Listener与之关联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SQSListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;receive message:&#123;&#125;&quot;</span>, ((TextMessage)message).getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上文创建过程</span></span><br><span class="line">    SQSConnection sqsConnection = sqsConnectionFactory.createConnection();</span><br><span class="line">    sqsConnection.start();</span><br><span class="line">    Session session = sqsConnection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">    Queue queue = session.createQueue(<span class="string">&quot;YeahmobiFIFOWork.fifo&quot;</span>);</span><br><span class="line"><span class="comment">//创建消费者, 对消息进行消费</span></span><br><span class="line">Message message = session.createConsumer(queue).setMessageListener(<span class="keyword">new</span> SQSListener());</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Amazon-SQS-的特性&quot;&gt;&lt;a href=&quot;#Amazon-SQS-的特性&quot; class=&quot;headerlink&quot; title=&quot;Amazon SQS 的特性&quot;&gt;&lt;/a&gt;Amazon SQS 的特性&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Simple Queue S</summary>
      
    
    
    
    
    <category term="amazon" scheme="http://voidbean.top/tags/amazon/"/>
    
  </entry>
  
  <entry>
    <title>GO LANG交叉编译</title>
    <link href="http://voidbean.top/2022/01/30/golang%20note/"/>
    <id>http://voidbean.top/2022/01/30/golang%20note/</id>
    <published>2022-01-30T02:27:17.000Z</published>
    <updated>2022-01-30T03:06:52.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GO-Lang"><a href="#GO-Lang" class="headerlink" title="GO Lang"></a>GO Lang</h1><h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>Mac</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure><p>Windows </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build main.go</span><br><span class="line"></span><br><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=linux</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build main.go</span><br></pre></td></tr></table></figure><p>Linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure><p>Goland配置:</p><img src="/pic/image-20210609174410628.png" alt="image-20210609174410628" style="zoom:33%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GO-Lang&quot;&gt;&lt;a href=&quot;#GO-Lang&quot; class=&quot;headerlink&quot; title=&quot;GO Lang&quot;&gt;&lt;/a&gt;GO Lang&lt;/h1&gt;&lt;h2 id=&quot;交叉编译&quot;&gt;&lt;a href=&quot;#交叉编译&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="go" scheme="http://voidbean.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>WebClient 在 Spring Gateway and Spring Webflux 中的集成应用</title>
    <link href="http://voidbean.top/2020/06/19/WebClient%20in%20Spring%20Gateway%20and%20Spring%20Webflux/"/>
    <id>http://voidbean.top/2020/06/19/WebClient%20in%20Spring%20Gateway%20and%20Spring%20Webflux/</id>
    <published>2020-06-19T07:11:27.000Z</published>
    <updated>2022-02-07T06:26:27.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebClient-在-Spring-Gateway-and-Spring-Webflux-中的集成应用"><a href="#WebClient-在-Spring-Gateway-and-Spring-Webflux-中的集成应用" class="headerlink" title="WebClient 在 Spring Gateway and Spring Webflux 中的集成应用"></a>WebClient 在 Spring Gateway and Spring Webflux 中的集成应用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>由于Spring Gateway内部不再支持阻塞的http请求调用，原来的<code>Feign</code>与带有<code>@LoadBalanced</code>的<code>RestTemplate</code>均无法继续使用。</p><blockquote><p>“because it uses blocking io by default therefor it is incompatible.”</p><p><a href="https://github.com/spring-cloud/spring-cloud-gateway/issues/1099">A bug cause by feignclient and spring cloud gateway ,use Spring cloud Greenwich.RELEASE #1099</a></p></blockquote><p>于是根据<strong>spencergibb</strong>的建议，我将项目中的通讯组件由Feign调整为了WebClient。</p><h2 id="WebClient的创建"><a href="#WebClient的创建" class="headerlink" title="WebClient的创建"></a>WebClient的创建</h2><h3 id="创建WebClient"><a href="#创建WebClient" class="headerlink" title="创建WebClient"></a>创建WebClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebClient webClient = WebClient.builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;http://127.0.0.1:8080&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>直接import后调用WebClient即可。其中<code>baseUrl</code>为创建的这个<code>webClient</code>的基本地址，此项可以不配置，如果配置了baseUrl，后续调用WebClient时只需要加上对应的path路径即可。</p><p>除此之外，还可以加入如<code>.defaultCookie(&quot;username&quot;,&quot;admin&quot;)</code>这样的默认配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebClient webClient = WebClient.builder()</span><br><span class="line">    .defaultCookie(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">    .defaultHeader(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">    .baseUrl(<span class="string">&quot;http://127.0.0.1:8080&quot;</span>).build();</span><br></pre></td></tr></table></figure><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>原生的WebClient并不支持负载均衡，需要引入其他的负载均衡组件（如ribbon）同时指定WebClient的Filter来实现负载均衡。</p><p>这里以ribbon为例，首先构建一个负责生成WebClient的Bean，同时引入LoadBalancerClient。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClientFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerExchangeFilterFunction loadBalancerExchangeFilterFunction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClientFactory</span><span class="params">( LoadBalancerClient loadBalancerClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancerClient = loadBalancerClient;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancerExchangeFilterFunction = <span class="keyword">new</span> LoadBalancerExchangeFilterFunction(loadBalancerClient);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后创建WebClient的方法类似上文中的创建方式，只需要多加一个<code>filter(loadBalancerExchangeFilterFunction)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebClient <span class="title">getWebClientByServiceName</span><span class="params">(String serviceName)</span></span>&#123;</span><br><span class="line">    String baseUrl = <span class="string">&quot;http://&quot;</span>+serviceName;</span><br><span class="line">    <span class="keyword">return</span> WebClient.builder()</span><br><span class="line">            .baseUrl(baseUrl)</span><br><span class="line">            .filter(loadBalancerExchangeFilterFunction)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只需要保证<code>baseUrl</code>为<code>http://服务名</code>即可，后续webclient在调用时就会自动进入LoadBalancerClient（ribbon对应的实现类为RibbonLoadBalancerClient），调用<code>choose</code>方法进行负载均衡。</p><h2 id="WebClient的使用"><a href="#WebClient的使用" class="headerlink" title="WebClient的使用"></a>WebClient的使用</h2><h3 id="请求调用"><a href="#请求调用" class="headerlink" title="请求调用"></a>请求调用</h3><p>通过上文的方法获取到webClinet后，首先根据要调用的服务方的接口方法类型，选择get、post等方法，这里既可以使用<code>webClient.get()</code>、<code>webClient.post()</code>，也可以使用<code>webClient.method(HttpMethod.GET)</code>的形式。</p><p>之后开始构建请求地址、请求头、请求参数、请求体、响应类型等信息。范例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;?&gt; mono = webClient.post().uri(path)</span><br><span class="line">        .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">        .body(BodyInserters.fromObject(body))</span><br><span class="line">        .retrieve()</span><br><span class="line">        .bodyToMono(responseClass.class);</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>注意链式调用中的各个方法的执行顺序，大部分参数在body()前配置，添加请求参数方法attributes()需要在之后配置。具体顺序需要在写代码时注意各个方法的返回值。</p></blockquote><blockquote><p>bodyToMono方法中的class为接受响应结果的实体类的class。</p></blockquote></blockquote><p>除了上文这种创建方式，也可以直接根据创建的<code>ServerHttpRequest</code>来创建Mono。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Mono&lt;?&gt; executeRequest(ServerHttpRequest request, Class responseClass)&#123;</span><br><span class="line">    WebClient.RequestBodySpec requestBodySpec = WebClient.builder()</span><br><span class="line">            .filter(loadBalancerExchangeFilterFunction).build()</span><br><span class="line">            .method(request.getMethod())</span><br><span class="line">            .uri(request.getURI())</span><br><span class="line">            .headers(httpHeaders -&gt; &#123;</span><br><span class="line">                httpHeaders.addAll(request.getHeaders());</span><br><span class="line">                httpHeaders.remove(<span class="string">&quot;Host&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">     <span class="keyword">if</span>(requiresBody(request.getMethod()))&#123;</span><br><span class="line">         <span class="keyword">return</span> requestBodySpec.body(BodyInserters.fromDataBuffers(request.getBody()))</span><br><span class="line">                 .attributes((Consumer&lt;Map&lt;String, Object&gt;&gt;) request.getQueryParams())</span><br><span class="line">                 .retrieve()</span><br><span class="line">                 .bodyToMono(responseClass);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> requestBodySpec</span><br><span class="line">                 .attributes((Consumer&lt;Map&lt;String, Object&gt;&gt;) request.getQueryParams())</span><br><span class="line">                 .retrieve()</span><br><span class="line">                 .bodyToMono(responseClass);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断请求类型是否需要传输请求体</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">requiresBody</span><span class="params">(HttpMethod method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">        <span class="keyword">case</span> PUT:</span><br><span class="line">        <span class="keyword">case</span> POST:</span><br><span class="line">        <span class="keyword">case</span> PATCH:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>这里的处理Request的方法来自于org.springframework.cloud.gateway.filter.WebClientHttpRoutingFilter#filter</p></blockquote><blockquote><p>ServerHttpRequest是个抽象接口，如果需要自己创建Request的话，建议参考org.springframework.http.server.reactive.AbstractServerHttpRequest，并手动实现一个Request类。</p></blockquote></blockquote><h3 id="请求结果的处理"><a href="#请求结果的处理" class="headerlink" title="请求结果的处理"></a>请求结果的处理</h3><p>非WebFlux项目下可使用同步阻塞的方式获取响应结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String response = mono.block(); <span class="comment">//上文获取到的mono，返回值类型根据bodyToMono中的class类型决定</span></span><br></pre></td></tr></table></figure><p>但是在WebFlux项目中无法在同一线程下调用阻塞方法来获取响应结果。</p><blockquote><p>毕竟用WebClient的目的就是为了非阻塞，如果还是使用block方法的话又何必切换为WebClient呢？</p><p><a href="https://github.com/spring-cloud/spring-cloud-gateway/issues/980">Gateway cannot “block()” #980</a></p></blockquote><p>目前我用到的处理方式有下面三种：</p><p>1、如果是Controller层直接返回该响应结果的话，可以直接<code>return mono;</code>，剩余的操作会由spring的框架本身进行处理。</p><p>2、如果是只需要异步调用WebClient发送Rest请求，并不需要根据返回结果做相应处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mono.subscribe(response-&gt;&#123;</span><br><span class="line">    log.info(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、如果需要对响应结果做处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设我需要对响应结果的报文内容做处理</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;?&gt; myclient()&#123;</span><br><span class="line">    String res = <span class="string">&quot;response:&quot;</span>;</span><br><span class="line">    <span class="comment">//getMono方法用于返回上文中提到的webClient创建的mono对象，Response类型为String。</span></span><br><span class="line">    Mono&lt;String&gt; mono = (Mono&lt;String&gt;) baseClient.getMono(String.class);</span><br><span class="line">    <span class="keyword">return</span> mono.flatMap(response-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(res.concat(response));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，在一般方法中flatMap中直接return一个<code>Mono.just()</code>创建的新mono对象即可，但是如果是在Spring Gateway 的Filter中做类似处理的话，需要返回的是<code>chain.filter(exchange);</code></p><blockquote><p>spencergibb给出的原因</p><p>“the webclient all returns a Mono and needs to be part of the filter chain. So instead of <code>return Mono.just(s)</code>.”</p><p><a href="https://github.com/spring-cloud/spring-cloud-gateway/issues/1090">How to call another micro-service on GatewayFilterFactory ? #1090</a></p></blockquote><h3 id="响应异常状态的处理"><a href="#响应异常状态的处理" class="headerlink" title="响应异常状态的处理"></a>响应异常状态的处理</h3><p>由于reactor编程的特点，对于响应异常状态的处理，需要在Mono创建完成异常处理的装配。这里以token鉴权为例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">userAuth</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getWebClientByServiceName(authServiceName)  <span class="comment">//上文中获取WebClient的方法</span></span><br><span class="line">            .get().uri(contextPath + PATH)</span><br><span class="line">            .header(HttpHeaders.AUTHORIZATION,BEARER+token)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .onStatus(HttpStatus::is4xxClientError, clientResponse -&gt; &#123;</span><br><span class="line">                <span class="comment">//MyException是我自定义的异常，根据具体情况自行选择异常处理类</span></span><br><span class="line">                <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> MyException()</span><br><span class="line">                        .setCode(Constant.NO_AUTH)</span><br><span class="line">                        .setHttpStatus(HttpStatus.UNAUTHORIZED));</span><br><span class="line">            &#125;)</span><br><span class="line">            .bodyToMono(String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>WebClient总体而言可拓展性还是蛮高的，像负载均衡这种东西可以直接调一个filter即可完成。大部分操作可以提前装配，使用时可以直接调用，复用起来也比较舒服。唯一的问题是reactor编程挺反直觉的，上手比较困难，要接触其中的任何一个组件，都少不了要去学习webflux全家桶。</p><p>好久没有更新博客了，目前应用Spring WebFlux系列的项目太少，经验还是不足，后面大概还会继续整理一些相关的内容，个人还是感觉这一套体系挺值得去学习的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WebClient-在-Spring-Gateway-and-Spring-Webflux-中的集成应用&quot;&gt;&lt;a href=&quot;#WebClient-在-Spring-Gateway-and-Spring-Webflux-中的集成应用&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="SpringCloud" scheme="http://voidbean.top/tags/SpringCloud/"/>
    
    <category term="WebFlux" scheme="http://voidbean.top/tags/WebFlux/"/>
    
    <category term="WebClient" scheme="http://voidbean.top/tags/WebClient/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 与 EHCache的使用教程</title>
    <link href="http://voidbean.top/2019/10/12/Spring%20Cache%20X%20EHCache/"/>
    <id>http://voidbean.top/2019/10/12/Spring%20Cache%20X%20EHCache/</id>
    <published>2019-10-12T09:23:10.000Z</published>
    <updated>2021-01-08T08:59:17.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cache-X-EHCache"><a href="#Spring-Cache-X-EHCache" class="headerlink" title="Spring Cache X EHCache"></a>Spring Cache X EHCache</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启 cache 缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ehcache 缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="xml配置文件"><a href="#xml配置文件" class="headerlink" title="xml配置文件"></a>xml配置文件</h3><p>建立resources&#x2F;ehcache.xml，内容范例如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    配置提供者</span></span><br><span class="line"><span class="comment">        1、peerDiscovery，提供者方式，有两种方式：自动发现(automatic)、手动配置(manual)</span></span><br><span class="line"><span class="comment">        2、rmiUrls，手动方式时提供者的地址，多个的话用|隔开</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cacheManagerPeerProviderFactory</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;net.sf.ehcache.distribution.RMICacheManagerPeerProviderFactory&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">properties</span>=<span class="string">&quot;peerDiscovery=manual,rmiUrls=//10.88.2.130:40001/route&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     自动发现的配置, 需要对应的服务器开启MultiCast, 否则应用无法启动</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     &lt;cacheManagerPeerProviderFactory</span></span><br><span class="line"><span class="comment">             class=&quot;net.sf.ehcache.distribution.RMICacheManagerPeerProviderFactory&quot;</span></span><br><span class="line"><span class="comment">             properties=&quot;peerDiscovery=automatic, multicastGroupAddress=230.0.0.1,</span></span><br><span class="line"><span class="comment">    multicastGroupPort=40001, timeToLive=32&quot;/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    配置监听器</span></span><br><span class="line"><span class="comment">        1、hostName 主机地址</span></span><br><span class="line"><span class="comment">        2、port 端口</span></span><br><span class="line"><span class="comment">        3、socketTimeoutMillis socket子模块的超时时间，默认是2000ms</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cacheManagerPeerListenerFactory</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;net.sf.ehcache.distribution.RMICacheManagerPeerListenerFactory&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">properties</span>=<span class="string">&quot;hostName=10.88.2.113, port=40001, socketTimeoutMillis=2000&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 默认缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxEntriesLocalHeap</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxEntriesLocalDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- cachetest缓存 缓存时间为5秒 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;route&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;300&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;300&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        配置缓存事件监听器</span></span><br><span class="line"><span class="comment">            replicateAsynchronously  操作是否异步,默认值为true.</span></span><br><span class="line"><span class="comment">            replicatePuts 添加操作是否同步到集群内的其他缓存,默认为true.</span></span><br><span class="line"><span class="comment">            replicateUpdates 更新操作是否同步到集群内的其他缓存,默认为true.</span></span><br><span class="line"><span class="comment">            replicateUpdatesViaCopy 更新之后的对象是否复制到集群中的其他缓存(true);</span></span><br><span class="line"><span class="comment">            replicateRemovals 删除操作是否同步到集群内的其他缓存,默认为true.</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cacheEventListenerFactory</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;net.sf.ehcache.distribution.RMICacheReplicatorFactory&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">properties</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">                replicateAsynchronously=true,</span></span></span><br><span class="line"><span class="string"><span class="tag">                replicatePuts=true,</span></span></span><br><span class="line"><span class="string"><span class="tag">                replicateUpdates=true,</span></span></span><br><span class="line"><span class="string"><span class="tag">                replicateUpdatesViaCopy=true,</span></span></span><br><span class="line"><span class="string"><span class="tag">                replicateRemovals=true &quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 初始化缓存，以及自动设置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bootstrapCacheLoaderFactory</span> <span class="attr">class</span>=<span class="string">&quot;net.sf.ehcache.distribution.RMIBootstrapCacheLoaderFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">&quot;route&quot; #命名空间，在后面的Spring注解中会用到，表明缓存所属的位置</span></span><br><span class="line"><span class="attr">eternal</span>=<span class="string">&quot;false&quot;#是否永久有效</span></span><br><span class="line"><span class="attr">maxElementsInMemory</span>=<span class="string">&quot;100&quot;#缓存的最大数量</span></span><br><span class="line"><span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;#系统宕机时是否将其保存至磁盘</span></span><br><span class="line"><span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;#是否持久化磁盘缓存</span></span><br><span class="line"><span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;#清除对象缓存前的闲置时间</span></span><br><span class="line"><span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;300&quot;#清除对象缓存前的永久有效时间</span></span><br><span class="line"><span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;#缓存策略, FIFO: 先进先出, LFU: 最少访问次数, LRU: 最近最少使用</span></span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-使用"><a href="#Spring-Boot-使用" class="headerlink" title="Spring Boot 使用"></a>Spring Boot 使用</h2><h3 id="yaml配置"><a href="#yaml配置" class="headerlink" title="yaml配置"></a>yaml配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">ehcache:</span></span><br><span class="line">    <span class="comment"># 根据具体的ehcache.xml地址具体配置, classpath为resources文件夹的根路径</span></span><br><span class="line">      <span class="attr">config:</span> <span class="string">classpath:ehcache.xml</span></span><br></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="EnableCaching"><a href="#EnableCaching" class="headerlink" title="@EnableCaching"></a>@EnableCaching</h4><p>需要在启动类中加入该注解，用于启动Cache功能。</p><h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p>范例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value = &quot;route&quot;,key=&quot;#id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;once&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> id+<span class="string">&quot;&amp; count:&quot;</span>+count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标注该方法（也可以标记在类上，表示该类均采用缓存）的返回值为缓存，缓存所属命名空间为“route”，对应的key为传来的id号（类似于Map），之后每次调用testGet(id)方法时，如果对应的id在route中存在缓存，那么不再执行该方法，直接取出缓存中的值。</p><p>此处应注意一点，比如testGet方法位于@Service注解（或者其他的标注为Bean的注解）的CacheService类中，那么该类内部的其他的方法比如CacheService#getCache(String id)是无法触发缓存机制的，必须要由其他类来调用CacheService#testGet(String id)方法才能够触发缓存机制。</p><p>除此之外，该注解的参数中还有condition，为缓存条件，默认为空。使用SpEL编写，返回值为true时才会执行缓存。范例：<code>@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”)</code></p><h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><p>范例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CachePut(value = &quot;route&quot;,key=&quot;#id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">putCache</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> id+<span class="string">&quot;&amp; count:&quot;</span>+count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标注该方法为更新缓存的方法，当执行该方法时，会自动前往route命名空间下的key为id的缓存值，对其进行更新。</p><p>注意此处的返回值务必与Cacheable的一致，否则会导致获取缓存时类型冲突的问题。</p><p>同样该注解的参数中也包含condition，不再赘述。</p><h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p>范例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value = &quot;route&quot;,key=&quot;#id&quot;,allEntries=false,beforeInvocation=false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标注该方法执行时会自动移除route命名空间下key为id的缓存值，其中<code>allEntries</code>表示是否在执行该方法的时候清空其他的key，<code>beforeInvocation</code>表示清除缓存操作在方法执行前还是执行后。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Cache-X-EHCache&quot;&gt;&lt;a href=&quot;#Spring-Cache-X-EHCache&quot; class=&quot;headerlink&quot; title=&quot;Spring Cache X EHCache&quot;&gt;&lt;/a&gt;Spring Cache X EHCac</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="http://voidbean.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装</title>
    <link href="http://voidbean.top/2019/09/25/DockerInstall/"/>
    <id>http://voidbean.top/2019/09/25/DockerInstall/</id>
    <published>2019-09-25T05:19:03.000Z</published>
    <updated>2021-01-08T08:59:17.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker安装及V2Ray部署"><a href="#Docker安装及V2Ray部署" class="headerlink" title="Docker安装及V2Ray部署"></a>Docker安装及V2Ray部署</h1><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line">    </span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"></span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line"><span class="meta">   $</span><span class="bash">(lsb_release -cs) \</span></span><br><span class="line"><span class="bash">   stable<span class="string">&quot;</span></span></span><br><span class="line">   </span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container start|restart|stop container_id //启停容器</span><br><span class="line">docker image ls //列出所有image</span><br><span class="line">docker container ls //列出所有容器</span><br><span class="line">docker exec -it 容器别名 /bin/bash|/bin/sh</span><br></pre></td></tr></table></figure><h2 id="V2Ray部署"><a href="#V2Ray部署" class="headerlink" title="V2Ray部署"></a>V2Ray部署</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//通过DockerFile安装(&#x27;.&#x27;指的是当前路径下的DockerFile,也可以修改为绝对路径/home/xxx/来指定DockerFile的位置)</span><br><span class="line">docker image build -t v2rayimage .</span><br><span class="line">sudo docker run -d --name v2ray -v /home/temp/docker/v2ray:/etc/v2ray -p 8888:8888 v2rayimage  v2ray -config=/etc/v2ray/config.json</span><br><span class="line">docker container start v2ray</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker安装及V2Ray部署&quot;&gt;&lt;a href=&quot;#Docker安装及V2Ray部署&quot; class=&quot;headerlink&quot; title=&quot;Docker安装及V2Ray部署&quot;&gt;&lt;/a&gt;Docker安装及V2Ray部署&lt;/h1&gt;&lt;h2 id=&quot;Docker安装&quot;</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://voidbean.top/tags/Docker/"/>
    
    <category term="Linux" scheme="http://voidbean.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Gateway Ribbon Rule Load Balancing Dynamic Effective</title>
    <link href="http://voidbean.top/2019/05/31/Spring%20Cloud%20Gateway%20Ribbon%20Rule%20Load%20Balancing%20Dynamic%20Effective/"/>
    <id>http://voidbean.top/2019/05/31/Spring%20Cloud%20Gateway%20Ribbon%20Rule%20Load%20Balancing%20Dynamic%20Effective/</id>
    <published>2019-05-31T02:46:27.000Z</published>
    <updated>2021-01-08T08:59:17.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-Gateway-Ribbon-Rule-Load-Balancing-Dynamic-Effective"><a href="#Spring-Cloud-Gateway-Ribbon-Rule-Load-Balancing-Dynamic-Effective" class="headerlink" title="Spring Cloud Gateway Ribbon Rule Load Balancing Dynamic Effective"></a>Spring Cloud Gateway Ribbon Rule Load Balancing Dynamic Effective</h1><h3 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h3><p>I was researching Spring Cloud Gateway some time ago and found that although routing can be dynamically configured, it is difficult to configure a specific load balancing policy for a service. It is very difficult to use if it is configured from a configuration file. Later, I checked the loading mechanism of the Ribbon Rule, which is lazy loading. This means that if I destroy the bean that was originally generated, the lazy loading mechanism will automatically reload the Ribbon Rule, which will make the dynamic load balancing policy take effect. </p><h3 id="Custom-load-balancing-policy"><a href="#Custom-load-balancing-policy" class="headerlink" title="Custom load balancing policy"></a>Custom load balancing policy</h3><p>Create the corresponding configuration class with @RibbonClients and @Configuration annotations, and then @Bean annotation to generate ribbonRule</p><p>When the <code>String name</code> defined here is the first time the load balancing policy is executed, the ribbon starts to be lazy loaded, and the corresponding service name is passed to the name variable through the @Value annotation.</p><p>Then select the required load balancing policy based on the service name. The load balancing policy that comes with the ribbon is in the com.netflix.loadbalancer package. I am here by writing LoadBalancerService#getLoadBalancerByName(name). This method will go to redis to find the key of the corresponding service name, and then take out its load balancing policy. If the default return polling policy is not found. RibbonDefintion is just a load-balanced entity class that I wrote for receiving redis storage, including the class name and Chinese translation name of the corresponding policy. In fact, as long as you get the load balancing class you want to use, you can directly use the getClass() to achive it.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbstractLoadBalancerRule rule =(AbstractLoadBalancerRule)Class.forName(com.netflix.loadbalancer.RoundRobinRule.getClass()).newInstance();  </span><br><span class="line">rule.initWithNiwsConfig(config)</span><br></pre></td></tr></table></figure><p>After that, the class will take effect on the corresponding load balancing policy in a lazy loading manner. After completing this part, we only need to destroy the bean when we receive the request to modify the load balancing policy.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guoyd.gateway.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.guoyd.gateway.model.RibbonDefinition;</span><br><span class="line"><span class="keyword">import</span> com.guoyd.gateway.service.LoadBalancerService;</span><br><span class="line"><span class="keyword">import</span> com.netflix.client.config.IClientConfig;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.*;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.ribbon.PropertiesFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.ribbon.RibbonClients;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ribbon默认全局配置</span></span><br><span class="line"><span class="comment"> * 负载均衡规则调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guoyd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RibbonClients(defaultConfiguration = RibbonDefaultConfiguration.class)</span></span><br><span class="line"><span class="comment">//@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonDefaultConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ribbon.client.name:#&#123;null&#125;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> IClientConfig config;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerService loadBalancerService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述:</span></span><br><span class="line"><span class="comment">     * 〈ribbonRule用于实现默认负载均衡方法。</span></span><br><span class="line"><span class="comment">     * 除ribbonRule()外,还有ribbonPing(),ribbonServerList(),serverListFilter()</span></span><br><span class="line"><span class="comment">     * 实现ribbon的其他默认配置〉</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:com.netflix.loadbalancer.IRule</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>: 1.0.0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>:guoyd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019/2/20 15:35</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//@RefreshScope</span></span><br><span class="line">    <span class="meta">@java</span>.lang.SuppressWarnings(<span class="string">&quot;squid:S2658&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先从redis中读取缓存,寻找是否有服务对应的负载均衡策略</span></span><br><span class="line">        RibbonDefinition ribbonDefinition = (RibbonDefinition) loadBalancerService.getLoadBalancerByName(name);</span><br><span class="line">        <span class="keyword">if</span>(ribbonDefinition!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            AbstractLoadBalancerRule rule = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rule = (AbstractLoadBalancerRule)Class.forName(ribbonDefinition.getRibbonClass()).newInstance();</span><br><span class="line">                rule.initWithNiwsConfig(config);</span><br><span class="line">                <span class="keyword">return</span> rule;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Invalid ribbon rule:&#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Take-the-bean-out-of-spring-context-and-destroy-it"><a href="#Take-the-bean-out-of-spring-context-and-destroy-it" class="headerlink" title="Take the bean out of spring context and destroy it"></a>Take the bean out of spring context and destroy it</h3><p>At first,we should get the ApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span><br></pre></td></tr></table></figure><p>to get the spring context.And then execute the destory() method.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NamedContextFactory contextFactory = applicationContext.getAutowireCapableBeanFactory().getBean(NamedContextFactory.class);</span><br><span class="line">contextFactory.destroy();</span><br></pre></td></tr></table></figure><h3 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h3><p>This method is very simple and rude, directly forcing the Bean to be destroyed and then using the original lazy loading mechanism to implement the hot effective load balancing strategy. I haven’t found any other methods at present. I can specifically kill the original Ribbon Rule method and directly kill all the current Ribbon Rules. Therefore, after the modification, other load balancing will be lazy once again during execution. Considering that the frequency of modifying the load balancing strategy itself is not too high, it does not consider its impact on execution efficiency. If there are other, better ways, welcome comments.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Cloud-Gateway-Ribbon-Rule-Load-Balancing-Dynamic-Effective&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Gateway-Ribbon-Rule-Load-Balancing-Dynamic</summary>
      
    
    
    
    
    <category term="SpringCloud" scheme="http://voidbean.top/tags/SpringCloud/"/>
    
    <category term="Gateway" scheme="http://voidbean.top/tags/Gateway/"/>
    
    <category term="Ribbon" scheme="http://voidbean.top/tags/Ribbon/"/>
    
    <category term="ENG" scheme="http://voidbean.top/tags/ENG/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Gateway Ribbon Rule 负载均衡动态生效(热加载)</title>
    <link href="http://voidbean.top/2019/05/31/Spring%20Cloud%20Gateway%20Ribbon%20Rule/"/>
    <id>http://voidbean.top/2019/05/31/Spring%20Cloud%20Gateway%20Ribbon%20Rule/</id>
    <published>2019-05-31T02:46:27.000Z</published>
    <updated>2021-01-08T08:59:17.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-Gateway-Ribbon-Rule-负载均衡动态生效-热加载"><a href="#Spring-Cloud-Gateway-Ribbon-Rule-负载均衡动态生效-热加载" class="headerlink" title="Spring Cloud Gateway Ribbon Rule 负载均衡动态生效(热加载)"></a>Spring Cloud Gateway Ribbon Rule 负载均衡动态生效(热加载)</h1><p>[TOC]</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间在研究Spring Cloud Gateway，发现虽然能动态配置路由，但是却难以为某个服务配置指定的负载均衡策略。如果是从配置文件里配置的话，非常难用。后来查了下Ribbon Rule的加载机制，是懒加载的方式，这就意味着如果我销毁了它原来生成的Bean，懒加载机制会自动重新加载Ribbon Rule，以此可以使得动态的负载均衡策略生效。</p><h3 id="自定义配置Ribbon-Rule的生成"><a href="#自定义配置Ribbon-Rule的生成" class="headerlink" title="自定义配置Ribbon Rule的生成"></a>自定义配置Ribbon Rule的生成</h3><p>用@RibbonClients和@Configuration注解建立对应的配置类，然后@Bean注解生成ribbonRule</p><p>这里定义的name变量为负载均衡策略初次执行时，ribbon开始进行懒加载，通过@Value注解传递对应的服务名到name变量中。</p><p>之后根据该服务名，选择需要的负载均衡策略。其中ribbon中自带的负载均衡策略在com.netflix.loadbalancer包中。我这里通过自己写的LoadBalancerService#getLoadBalancerByName(name)，这个方法会去redis中找寻对应服务名的key，然后取出它的负载均衡策略，如果找不到默认返回轮询策略。RibbonDefintion只是我写的一个临时用于接收redis存放的负载均衡的实体类，包含对应策略的类名和中文翻译名。实际上只要获取到了你想要用的负载均衡的类，可以直接使用对应负载均衡类的getClass属性即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbstractLoadBalancerRule rule =(AbstractLoadBalancerRule)Class.forName(com.netflix.loadbalancer.RoundRobinRule.getClass()).newInstance();  </span><br><span class="line">rule.initWithNiwsConfig(config)</span><br></pre></td></tr></table></figure><p>之后该类便会以懒加载的方式生效对应的负载均衡策略。完成这部分之后，我们只需要在接收到修改负载均衡策略请求的时候，去销毁掉Bean即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guoyd.gateway.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.guoyd.gateway.model.RibbonDefinition;</span><br><span class="line"><span class="keyword">import</span> com.guoyd.gateway.service.LoadBalancerService;</span><br><span class="line"><span class="keyword">import</span> com.netflix.client.config.IClientConfig;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.*;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.ribbon.PropertiesFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.ribbon.RibbonClients;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ribbon默认全局配置</span></span><br><span class="line"><span class="comment"> * 负载均衡规则调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guoyd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019/2/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RibbonClients(defaultConfiguration = RibbonDefaultConfiguration.class)</span></span><br><span class="line"><span class="comment">//@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonDefaultConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ribbon.client.name:#&#123;null&#125;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> IClientConfig config;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerService loadBalancerService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述:</span></span><br><span class="line"><span class="comment">     * 〈ribbonRule用于实现默认负载均衡方法。</span></span><br><span class="line"><span class="comment">     * 除ribbonRule()外,还有ribbonPing(),ribbonServerList(),serverListFilter()</span></span><br><span class="line"><span class="comment">     * 实现ribbon的其他默认配置〉</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:com.netflix.loadbalancer.IRule</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>: 1.0.0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>:guoyd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019/2/20 15:35</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//@RefreshScope</span></span><br><span class="line">    <span class="meta">@java</span>.lang.SuppressWarnings(<span class="string">&quot;squid:S2658&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先从redis中读取缓存,寻找是否有服务对应的负载均衡策略</span></span><br><span class="line">        RibbonDefinition ribbonDefinition = (RibbonDefinition) loadBalancerService.getLoadBalancerByName(name);</span><br><span class="line">        <span class="keyword">if</span>(ribbonDefinition!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            AbstractLoadBalancerRule rule = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rule = (AbstractLoadBalancerRule)Class.forName(ribbonDefinition.getRibbonClass()).newInstance();</span><br><span class="line">                rule.initWithNiwsConfig(config);</span><br><span class="line">                <span class="keyword">return</span> rule;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Invalid ribbon rule:&#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从上下文中取出Bean并销毁"><a href="#从上下文中取出Bean并销毁" class="headerlink" title="从上下文中取出Bean并销毁"></a>从上下文中取出Bean并销毁</h3><p>首先通过    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span><br></pre></td></tr></table></figure><p>将上下文拿到，然后调用<code>applicationContext.getAutowireCapableBeanFactory().getBean(NamedContextFactory.class)</code></p><p>然后执行destory()方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NamedContextFactory contextFactory = applicationContext.getAutowireCapableBeanFactory().getBean(NamedContextFactory.class);</span><br><span class="line">contextFactory.destroy();</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个方法非常简单粗暴，直接强制销毁掉Bean然后利用原有的懒加载机制实现的热生效负载均衡策略。我目前没找到别的方法，能够具体的干掉原来的Ribbon Rule的方法，直接干掉了当前所有的Ribbon Rule，所以在修改之后，其他的负载均衡在执行的时候也会重新懒加载一次。考虑到本身修改负载均衡策略的频率不会太高，所以没有考虑其对执行效率的影响。如果有其他更好的方法，欢迎评论指出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Cloud-Gateway-Ribbon-Rule-负载均衡动态生效-热加载&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Gateway-Ribbon-Rule-负载均衡动态生效-热加载&quot; class=&quot;headerlink&quot; title=&quot;Sp</summary>
      
    
    
    
    
    <category term="SpringCloud" scheme="http://voidbean.top/tags/SpringCloud/"/>
    
    <category term="Gateway" scheme="http://voidbean.top/tags/Gateway/"/>
    
    <category term="Ribbon" scheme="http://voidbean.top/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>FileBeat采集JSON日志</title>
    <link href="http://voidbean.top/2019/01/16/FileBeat%20JSON/"/>
    <id>http://voidbean.top/2019/01/16/FileBeat%20JSON/</id>
    <published>2019-01-16T09:12:32.000Z</published>
    <updated>2021-01-08T08:59:17.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FileBeat采集JSON日志"><a href="#FileBeat采集JSON日志" class="headerlink" title="FileBeat采集JSON日志"></a>FileBeat采集JSON日志</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用FileBeat采集JSON日志传输到logstash或者elasticsearch中，其中FileBeat的版本为5.5.0，Elasticsearch的版本为5.6.8</p><h2 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h2><h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><p>关于配置filebeat的json采集，主要需要注意的有以下几个配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#keys_under_root可以让字段位于根节点，默认为false</span><br><span class="line">json.keys_under_root: true</span><br><span class="line">#对于同名的key，覆盖原有key值</span><br><span class="line">json.overwrite_keys: true</span><br><span class="line">#message_key是用来合并多行json日志使用的，如果配置该项还需要配置multiline的设置，后面会讲</span><br><span class="line">json.message_key: message</span><br><span class="line">#将解析错误的消息记录储存在error.message字段中</span><br><span class="line">json.add_error_key: true</span><br></pre></td></tr></table></figure><p>参考的官方文档</p><blockquote><p><a href="https://www.elastic.co/guide/en/beats/filebeat/6.2/configuration-filebeat-options.html">https://www.elastic.co/guide/en/beats/filebeat/6.2/configuration-filebeat-options.html</a></p></blockquote><p>上面的几个配置项，只要配置了任意一项，filebeat就会开启json采集的功能。配置完成后filebeat会和采集正常的日志一样，对path中配置的json文件路径进行采集，然后会将json报文中的字段存储到es中。</p><p>要注意的是，这种配置下关于multiline的配置，如果配置了multiline，会开启合并多条json日志的功能，如果不需要该功能请务必注释掉该yml中关于multiline的配置。</p><h3 id="多行合并配置"><a href="#多行合并配置" class="headerlink" title="多行合并配置"></a>多行合并配置</h3><p>在上面的配置中有提到关于multiline的配置，如果配置了multiline，那么必须配置message_key。在这两者配置完成后，假设日志如下json体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;01&quot;</span>,<span class="attr">&quot;message&quot;</span>:<span class="string">&quot;我是第一条信息&quot;</span>,<span class="attr">&quot;logDate&quot;</span>:<span class="string">&quot;2019-1-16 17:39:31&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;02&quot;</span>,<span class="attr">&quot;message&quot;</span>:<span class="string">&quot;我是第二条信息&quot;</span>,<span class="attr">&quot;logDate&quot;</span>:<span class="string">&quot;2019-1-16 17:40:20&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>filebeat会自动合并id为01和id为02的两条日志，在es中会看到对应的index中只有一条数据，其中message为<code>&quot;我是第一条信息我是第二条信息&quot;</code>。所以为了换行需要给原本json日志中的message加上标识符，用于标识是否需要合并为一条日志。范例如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;01&quot;</span>,<span class="attr">&quot;message&quot;</span>:<span class="string">&quot;[01-2019]我是第一条信息&quot;</span>,<span class="attr">&quot;logDate&quot;</span>:<span class="string">&quot;2019-1-16 17:39:31&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;02&quot;</span>,<span class="attr">&quot;message&quot;</span>:<span class="string">&quot;我是第二条信息&quot;</span>,<span class="attr">&quot;logDate&quot;</span>:<span class="string">&quot;2019-1-16 17:40:20&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;03&quot;</span>,<span class="attr">&quot;message&quot;</span>:<span class="string">&quot;[03-2019]我是第三条信息&quot;</span>,<span class="attr">&quot;logDate&quot;</span>:<span class="string">&quot;2019-1-16 17:41:34&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>然后对multiline相关的配置如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将&#x27;[&#x27;作为新的一行的标识，如果message中不碰到&#x27;[&#x27;,则合并为一条日志</span></span><br><span class="line"><span class="attr">multiline.pattern:</span> <span class="string">^\[</span></span><br><span class="line"><span class="attr">multiline.negate:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">multiline.match:</span> <span class="string">after</span></span><br></pre></td></tr></table></figure><p>同时配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">decode_json_fields:</span></span><br><span class="line">      <span class="attr">fields:</span> [<span class="string">&#x27;message&#x27;</span>]</span><br><span class="line">      <span class="attr">target:</span> <span class="string">json</span></span><br></pre></td></tr></table></figure><p>配置完成后再次启动filebeat，则对应的es中的日志为两条</p><p>其中第一条的message：<code>[01-2019]我是第一条信息我是第二条信息</code></p><p>第二条的message：<code>[03-2019]我是第三条信息</code></p><p>通过这种方式可以实现多行日志的合并与分离（顺带一提如果不需要多行合并的话务必记得注释掉multiline，不然你会发现你的json的日志在es中全部合并成了一条……）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FileBeat采集JSON日志&quot;&gt;&lt;a href=&quot;#FileBeat采集JSON日志&quot; class=&quot;headerlink&quot; title=&quot;FileBeat采集JSON日志&quot;&gt;&lt;/a&gt;FileBeat采集JSON日志&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="FileBeat" scheme="http://voidbean.top/tags/FileBeat/"/>
    
    <category term="Elasticsearch" scheme="http://voidbean.top/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch 通过获取Status获取备份文件占用空间的大小</title>
    <link href="http://voidbean.top/2019/01/14/ElasticSearchGetBackupSize/"/>
    <id>http://voidbean.top/2019/01/14/ElasticSearchGetBackupSize/</id>
    <published>2019-01-14T07:39:03.000Z</published>
    <updated>2021-01-08T08:59:17.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch-通过获取Status获取备份文件占用空间的大小"><a href="#ElasticSearch-通过获取Status获取备份文件占用空间的大小" class="headerlink" title="ElasticSearch 通过获取Status获取备份文件占用空间的大小"></a>ElasticSearch 通过获取Status获取备份文件占用空间的大小</h1><h2 id="ElasticSearch-API"><a href="#ElasticSearch-API" class="headerlink" title="ElasticSearch API"></a>ElasticSearch API</h2><p>向 <code>127.0.0.1:9200/_snapshot/备份仓库名/快照名/_status</code>发送请求即可获取快照状态，可在stats.total_size_in_bytes中获取到备份的文件大小。注意的是这里获取的单位是byte，如果想直接获取已经转换好的单位，可以加上human参数，如下：</p><p><code>127.0.0.1:9200/_snapshot/备份仓库名/快照名/_status?human</code></p><p>此时返回的stats里会出现total_size字段，该字段会根据具体大小自动转换成MB、TB等单位。</p><p>关于这部分带human参数的返回字段描述，可以参照</p><blockquote><p><a href="https://github.com/elastic/elasticsearch/issues/18543#event-1647308307">https://github.com/elastic/elasticsearch/issues/18543#event-1647308307</a></p></blockquote><h2 id="JAVA-API"><a href="#JAVA-API" class="headerlink" title="JAVA API"></a>JAVA API</h2><p>如果要使用JAVA获取文件大小，首先要声明Client，我使用的是TransportClient，在配置文件中配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    #ElasticSearch地址</span><br><span class="line">    elasticsearch:</span><br><span class="line">      cluster-name: elasticsearch</span><br><span class="line">      cluster-nodes: 127.0.0.1:9300</span><br></pre></td></tr></table></figure><p>然后@AutoWired注入<code>TransportClient transportClient</code></p><p>在需要使用的地方加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] snapshotsName = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;快照1&quot;</span>,<span class="string">&quot;快照2&#125;; //快照名,必须是字符数组</span></span><br><span class="line"><span class="string">SnapshotsStatusRequest request = new SnapshotsStatusRequest().repository(&quot;</span>c备份仓库名<span class="string">&quot;).snapshots(snapshotsName);</span></span><br><span class="line"><span class="string">SnapshotsStatusResponse response = transportClient.admin().cluster().snapshotsStatus(request).actionGet(); //通过client和request获取response</span></span><br><span class="line"><span class="string">List&lt;SnapshotStatus&gt; list = response.getSnapshots(); //获取response中的数据</span></span><br></pre></td></tr></table></figure><p>至此获得到了snapshot status的信息。</p><p>其他的Client获取Response可以参考官方文档：</p><blockquote><p>SnapShotStatus JAVA API<br><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.x/java-rest-high-snapshot-snapshots-status.html">https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.x/java-rest-high-snapshot-snapshots-status.html</a><br>Transport Clinet API<br><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/transport-client.html">https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/transport-client.html</a><br>RestHighLevelClient API<br><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.x/java-rest-high-getting-started-initialization.html">https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.x/java-rest-high-getting-started-initialization.html</a></p></blockquote><p>可惜JAVA API中的实体类SnapshotStatus并没有针对human参数获取转换好格式的文件大小，只能通过<code>snapshotStatusList.get(0).getStats().getTotalSize()</code>获取到Long型的byte单位的备份文件大小。如果要手动转换，手动转换如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">revertSize</span><span class="params">(Long size)</span></span>&#123;</span><br><span class="line">    Float sizeFloat = size.floatValue();</span><br><span class="line">    String[] NAME = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;byte&quot;</span>,<span class="string">&quot;KB&quot;</span>,<span class="string">&quot;MB&quot;</span>,<span class="string">&quot;GB&quot;</span>,<span class="string">&quot;TB&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sizeFloat/<span class="number">1024</span>&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        sizeFloat=sizeFloat/<span class="number">1024</span>;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;.00&quot;</span>).format(sizeFloat) + NAME[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ElasticSearch-通过获取Status获取备份文件占用空间的大小&quot;&gt;&lt;a href=&quot;#ElasticSearch-通过获取Status获取备份文件占用空间的大小&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch 通过获取</summary>
      
    
    
    
    
    <category term="elasticsearch" scheme="http://voidbean.top/tags/elasticsearch/"/>
    
    <category term="JAVA" scheme="http://voidbean.top/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>通过assembly自定义maven打包方式</title>
    <link href="http://voidbean.top/2018/12/27/assembly%20with%20maven/"/>
    <id>http://voidbean.top/2018/12/27/assembly%20with%20maven/</id>
    <published>2018-12-27T02:12:22.000Z</published>
    <updated>2021-01-08T08:59:17.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过assembly自定义maven打包方式"><a href="#通过assembly自定义maven打包方式" class="headerlink" title="通过assembly自定义maven打包方式"></a>通过assembly自定义maven打包方式</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近要统一打包输出的格式，结构如下：</p><p><img src="https://bean-markdown.nos-eastchina1.126.net/bootpackgae.png" alt="打包结构"></p><p>为了实现SpringBoot自动打包成图中的格式，这次用assembly以手动修改POM添加脚本的方式实现自动打包</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>首先POM中需要引入如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jar生成--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自定义打包配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--finalName用于配置最后生成的文件名 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--生成包的末尾添加assembly id，一般关闭 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptors</span>&gt;</span></span><br><span class="line">                         <span class="comment">&lt;!--加载指定的配置文件--&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>src/assembly/assembly-descriptor.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptors</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中maven-compiler-plugin是用来将代码生成jar的工具，maven-assembly-plugin是用来生成指定格式的工具。</p><p>配置完成后进入<descriptor>标签里指定的位置建xml文件，这里是src&#x2F;assembly&#x2F;assembly-descriptor.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">assembly</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 http://maven.apache.org/xsd/assembly-1.1.3.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>my-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">formats</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--打包生成后的格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">format</span>&gt;</span>zip<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">formats</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includeBaseDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">includeBaseDirectory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileSet</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--脚本所在的文件夹，以及打包后将脚本输出到哪个文件夹中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/scripts<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>alarm/bin<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 哪些文件会被提取 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>*.sh<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 文件权限及编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileMode</span>&gt;</span>0755<span class="tag">&lt;/<span class="name">fileMode</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lineEnding</span>&gt;</span>unix<span class="tag">&lt;/<span class="name">lineEnding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileSet</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--同上，这里配置的是配置文件所在的文件夹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>alarm/conf<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lineEnding</span>&gt;</span>unix<span class="tag">&lt;/<span class="name">lineEnding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--artifact --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileSet</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--这里的target是maven-compiler-plugin生成该项目的jar包的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>alarm/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>*.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileMode</span>&gt;</span>0755<span class="tag">&lt;/<span class="name">fileMode</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencySets</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--这里是将该项目依赖的所有jar包存入lib文件夹中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>alarm/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">useProjectArtifact</span>&gt;</span>false<span class="tag">&lt;/<span class="name">useProjectArtifact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">useProjectAttachments</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useProjectAttachments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencySet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencySets</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h3><p>在完成以上配置后，只需在<directory>指定的位置建立scripts&#x2F;start.sh和stop.sh两个脚本即可完成。具体启动脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">basepath=$(cd `dirname $0`;cd &#x27;../&#x27;; pwd)</span><br><span class="line">echo &quot;path:&quot;$basepath</span><br><span class="line">jarHome=&#x27;/my.jar&#x27;</span><br><span class="line">echo &quot;Starting my service&quot;</span><br><span class="line">ls_date=`date +%Y%m%d`</span><br><span class="line">if [ ! -d &quot;$&#123;basepath&#125;/log&quot; ]; then</span><br><span class="line">  mkdir $&#123;basepath&#125;/log</span><br><span class="line">fi</span><br><span class="line">if [ ! -d &quot;$basepath/log/$&#123;ls_date&#125;&quot; ]; then</span><br><span class="line">  mkdir $basepath/log/$&#123;ls_date&#125;</span><br><span class="line">fi</span><br><span class="line">nohup java -jar $basepath$jarHome --spring.config.location=$basepath/conf/server-attach.yml,$basepath/conf/server-shared.yml&gt; $basepath/log/$&#123;ls_date&#125;/$&#123;ls_date&#125;.log &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要命令是获取当天日期，然后在log文件夹下建立指定日期的文件夹，并将日志存放进去。其中–spring.config.location用于加载指定的配置文件，多个配置文件用逗号分割。</p><p>停止脚本通过ps -ef获取进程id然后kill，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">my=`ps -ef |grep my.jar | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">kill -9 $my</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上配置完成后使用mvn package命令即可自动打成一个zip压缩包，包内包含bin、conf、lib文件夹，可用启动脚本一键启动。实际上这里能修改的地方还有很多，包括启动脚本也可以用其他方式如java -classpath方式启动等等，具体的可以根据自身需求进行相应修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通过assembly自定义maven打包方式&quot;&gt;&lt;a href=&quot;#通过assembly自定义maven打包方式&quot; class=&quot;headerlink&quot; title=&quot;通过assembly自定义maven打包方式&quot;&gt;&lt;/a&gt;通过assembly自定义maven打包</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="http://voidbean.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>ESPER引擎执行告警判断</title>
    <link href="http://voidbean.top/2018/12/27/ESPER/"/>
    <id>http://voidbean.top/2018/12/27/ESPER/</id>
    <published>2018-12-27T02:10:13.000Z</published>
    <updated>2021-01-08T08:59:17.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ESPER引擎执行告警判断"><a href="#ESPER引擎执行告警判断" class="headerlink" title="ESPER引擎执行告警判断"></a>ESPER引擎执行告警判断</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>ESPER需要的pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.espertech<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>esper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>初始化时,需要EPServiceProvider和EPAdministrator先进行初始化。在初始化完成后，可以直接使用EPAdministrator的createEPL方法添加EPL语句进入ESPER引擎。</p><p>其中createEPL的参数(String epl,String key)中,前者是EPL语句,后者是该EPL语句的名字,类似key-value形式,后期在删除、修改EPL语句时可通过这个key来获取该EPL语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化必须的变量</span></span><br><span class="line">EPServiceProvider epService;</span><br><span class="line">EPAdministrator admin;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化Esper引擎,同时装载数据库中enable的告警策略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">initJudge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;初始化Esper引擎&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    epService = EPServiceProviderManager.getDefaultProvider();</span><br><span class="line">    admin = epService.getEPAdministrator();</span><br><span class="line">    <span class="comment">//获取告警策略,之后用for循环取出告警策略中的EPL语句     </span></span><br><span class="line">    List&lt;AlarmPolicyWithParam&gt; alarmPolicyList = alarmPolicyService.getPolicyAllWithEnable(); </span><br><span class="line">    <span class="keyword">for</span> (AlarmPolicy alarmPolicy:alarmPolicyList) &#123;</span><br><span class="line">        String epl = alarmPolicy.getEpl();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//admin.createEPL用于添加EPL语句,addListener用于执行告警动作</span></span><br><span class="line">                admin.createEPL(</span><br><span class="line">                     epl, <span class="string">&quot;alarm_&quot;</span> + alarmPolicy.getId()).addListener(</span><br><span class="line">                    <span class="keyword">new</span> BaseListener()</span><br><span class="line">                );</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;存在非法epl语句,请检查告警策略id:&quot;</span>+alarmPolicy.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里admin.addListener(new BaseListener())方法用于添加监听器，当满足告警条件时自动执行addListener里的BaseListener().update()方法,BaseListener如下,该类需要实现UpdateListener接口。其中EventBeans[0]是EPL语句执行后查询出的结果，可用getUnderlying()取出该结果的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseListener</span> <span class="keyword">implements</span> <span class="title">UpdateListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(EventBean[] eventBeans, EventBean[] eventBeans1)</span></span>&#123;</span><br><span class="line">         log.info(<span class="string">&quot;告警条件触发!&quot;</span>);</span><br><span class="line">         Metric metric = (Metric)eventBeans[<span class="number">0</span>].getUnderlying();</span><br><span class="line">         log.info(metric.getName()+<span class="string">&quot;触发告警&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改、删除EPL语句"><a href="#修改、删除EPL语句" class="headerlink" title="修改、删除EPL语句"></a>修改、删除EPL语句</h2><p>如果出现EPL语句需要修改或者删除，可以根据之前EPL语句存储时设置的key来获取到对应的EPL语句，然后执行覆盖或者删除操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除EPL</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delEPL</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="comment">//根据&quot;alarm_?&quot;来获取原EPL语句并销毁</span></span><br><span class="line">           EPStatement epStatement = admin.getStatement(<span class="string">&quot;alarm_&quot;</span>+id.toString());</span><br><span class="line">           epStatement.destroy();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception NullPointerException)&#123;</span><br><span class="line">           <span class="comment">//没有原EPL语句说明对应EPL未执行,无需删除</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//修改EPL语句</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> AlarmPolicy <span class="title">reEPL</span><span class="params">(AlarmPolicy alarmPolicy)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="comment">//根据&quot;alarm_x&quot;获取原EPL语句并销毁,之后重新加载新的EPL语句</span></span><br><span class="line">               EPStatement epStatement = </span><br><span class="line">                    admin.getStatement(<span class="string">&quot;alarm_&quot;</span> + alarmPolicy.getId().toString());</span><br><span class="line">               epStatement.destroy();</span><br><span class="line">                       admin.createEPL(</span><br><span class="line">                            alarmPolicy.getEpl(), <span class="string">&quot;alarm_&quot;</span> + alarmPolicy.getId()</span><br><span class="line">                       ).addListener(</span><br><span class="line">                               <span class="keyword">new</span> BaseListener()</span><br><span class="line">                       );</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">return</span> alarmPolicy;</span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception NullPointerException)&#123;</span><br><span class="line">           <span class="comment">//获取不到之前的添加的EPL语句,则直接将这条语句添加回Esper引擎</span></span><br><span class="line">           admin.createEPL(</span><br><span class="line">                alarmPolicy.getEpl(), <span class="string">&quot;alarm_&quot;</span> + alarmPolicy.getId()</span><br><span class="line">           ).addListener(</span><br><span class="line">                   <span class="keyword">new</span> BaseListener()</span><br><span class="line">           );</span><br><span class="line">           <span class="keyword">return</span> alarmPolicy;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="EPL语句执行"><a href="#EPL语句执行" class="headerlink" title="EPL语句执行"></a>EPL语句执行</h2><p>范例EPL语句:五秒内value值超过1,且次数大于两次,那么触发告警</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String epl = &quot;select * from com.dcits.domain.Metric.win:time_batch(5 sec) where 2 &lt; (select count(*) from com.dcits.domain.Metric.win:time(5 sec) where value &gt; 1)&quot;;</span><br></pre></td></tr></table></figure><p>其中com.dcits.domain.Metric为传入ESPER的ClassName()，通过<code>epService.getEPRuntime().sendEvent(metric);</code>可以直接将Metric的对象传入ESPER引擎,之后ESPER引擎会自动根据符合的EPL语句进行判断，如果判断符合条件，会跳到Listener执行updateListener的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ESPER引擎执行告警判断&quot;&gt;&lt;a href=&quot;#ESPER引擎执行告警判断&quot; class=&quot;headerlink&quot; title=&quot;ESPER引擎执行告警判断&quot;&gt;&lt;/a&gt;ESPER引擎执行告警判断&lt;/h1&gt;&lt;h2 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; c</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="http://voidbean.top/tags/SpringBoot/"/>
    
    <category term="ESPER" scheme="http://voidbean.top/tags/ESPER/"/>
    
  </entry>
  
  <entry>
    <title>通过RestTemplate向Eureka注册的服务发送请求</title>
    <link href="http://voidbean.top/2018/12/14/resttemplate/"/>
    <id>http://voidbean.top/2018/12/14/resttemplate/</id>
    <published>2018-12-14T06:10:13.000Z</published>
    <updated>2021-01-08T08:59:17.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过RestTemplate向Eureka注册的服务发送请求"><a href="#通过RestTemplate向Eureka注册的服务发送请求" class="headerlink" title="通过RestTemplate向Eureka注册的服务发送请求"></a>通过RestTemplate向Eureka注册的服务发送请求</h1><h3 id="RestTemplate意义"><a href="#RestTemplate意义" class="headerlink" title="RestTemplate意义"></a>RestTemplate意义</h3><p>常规情况下发送HTTP请求，如用HttpURLConnection之类的方式使用起来非常麻烦，要手动配置连接时的各种配置项，比如下面就是一个带JSON报文体的POST请求代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">conn.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">conn.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">conn.setRequestProperty(<span class="string">&quot;connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>);</span><br><span class="line">conn.setUseCaches(<span class="keyword">false</span>);<span class="comment">//设置不要缓存</span></span><br><span class="line">conn.setInstanceFollowRedirects(<span class="keyword">true</span>);</span><br><span class="line">conn.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">conn.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">conn.connect();</span><br><span class="line"><span class="comment">//post请求</span></span><br><span class="line">OutputStreamWriter out = <span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">conn.getOutputStream()</span><br><span class="line">);</span><br><span class="line">out.write(jsonArray.toString());</span><br><span class="line">out.flush();</span><br><span class="line"><span class="comment">//获取响应</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line"><span class="keyword">new</span> InputStreamReader(conn.getInputStream())</span><br><span class="line">);</span><br><span class="line">String lines;</span><br><span class="line">String response=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>((lines = reader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">lines = <span class="keyword">new</span> String(lines.getBytes(),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">response+=lines;</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line">conn.disconnect();</span><br></pre></td></tr></table></figure><p>这部分代码可以说是又丑又长，而如果采用RestTemplate则可以非常方便的完成以上的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;SuccessResult&gt; response = restTemplate.postForEntity(url, request, SuccessResult.class);</span><br></pre></td></tr></table></figure><p>同时RestTemplate也支持直接通过Eureka的Service-id来获取对应服务的绝对地址来发送请求，所以当原服务地址发生改变时，该功能代码无需改变，通过Eureka可以直接获取修改后的新的服务地址。</p><h3 id="RestTemplate配置"><a href="#RestTemplate配置" class="headerlink" title="RestTemplate配置"></a>RestTemplate配置</h3><p>这里直接将RestTemplate注成Bean，可以新建一个类如RestTemplateConfig：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.setConnectTimeout(<span class="number">5000</span>).setReadTimeout(<span class="number">5000</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中@LoadBalanced可以为RestTemplate提供一个LoadBalancerInterceptor拦截器，该拦截器用于实现Eureka服务名转URL的功能。RestTemplateBuilder是1.4版本以后提供的一个生成RestTemplate实例的类，执行build()方法即可以返回一个RestTemplate的实例。除这种方法外，也可以直接return一个new RestTemplate()也可以。这里的setConnectTimeout是连接超时时间，readTimeout是获取资源时的等待时间。之后在调用RestAPI的地方注入Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlarmPolicyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此RestTemplate便可以直接使用了。</p><h3 id="RestTemplate的使用"><a href="#RestTemplate的使用" class="headerlink" title="RestTemplate的使用"></a>RestTemplate的使用</h3><p>首先是RestTemplate封装的几个方法</p><blockquote><p>原文：<a href="https://blog.csdn.net/itguangit/article/details/78825505">https://blog.csdn.net/itguangit/article/details/78825505</a> </p><p>delete() 在特定的URL上对资源执行HTTP DELETE操作</p><p>exchange()<br>在URL上执行特定的HTTP方法，返回包含对象的ResponseEntity，这个对象是从响应体中<br>映射得到的</p><p>execute() 在URL上执行特定的HTTP方法，返回一个从响应体映射得到的对象</p><p>getForEntity() 发送一个HTTP GET请求，返回的ResponseEntity包含了响应体所映射成的对象</p><p>getForObject() 发送一个HTTP GET请求，返回的请求体将映射为一个对象</p><p>postForEntity()<br>POST 数据到一个URL，返回包含一个对象的ResponseEntity，这个对象是从响应体中映射得<br>到的</p><p>postForObject() POST 数据到一个URL，返回根据响应体匹配形成的对象</p><p>headForHeaders() 发送HTTP HEAD请求，返回包含特定资源URL的HTTP头</p><p>optionsForAllow() 发送HTTP OPTIONS请求，返回对特定URL的Allow头信息</p><p>postForLocation() POST 数据到一个URL，返回新创建资源的URL</p><p>put() PUT 资源到特定的URL</p></blockquote><p>这里我们使用postForEntity()来通过Post方法传递一个JSON报文，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; sendRequest() &#123;</span><br><span class="line">     <span class="comment">//requestParam为要传输的实体类内容</span></span><br><span class="line">List&lt;SendRequestParam&gt; requestParam = myservice.getAll(); </span><br><span class="line">     ResponseEntity&lt;MyResult&gt; response = restTemplate.postForEntity(<span class="string">&quot;http://myservice/testAPI&quot;</span>,requestParam,MyResult.class);</span><br><span class="line">     <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先说下postForEntity中的三个参数<code>postForEntity(String url,Object request, Class&lt;T&gt; responseType)</code>，这里url可以直接配置为对应的接口地址如：<code>http://127.0.0.1:8080/testAPI</code>，也可以配置为Eureka服务名（RestTemplate必须有@LoadBalanced注解）:<code>http://服务名/具体接口名</code>。request为传输的报文体，responseType为响应体结构，在请求后获取响应报文后会根据这里配置的类型进行适配，如果对应接口返回的结构不符合这里的responseType会报异常。这里用到的MyResult是我自定义的一个类，其结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResult</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6191745064790884707L</span>;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时这里请求的testAPI的代码如下，其功能是将之前传输的JSON报文体封装到MyResult中并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/testAPI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; testAPI(<span class="meta">@RequestBody</span> Object object)&#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="keyword">new</span> MyResult().setCode(<span class="string">&quot;0000&quot;</span>).setMessage(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">            .setData(object));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此整套POST请求的流程便结束。</p><h3 id="SpringBoot启动时自动执行RestTemplate传输"><a href="#SpringBoot启动时自动执行RestTemplate传输" class="headerlink" title="SpringBoot启动时自动执行RestTemplate传输"></a>SpringBoot启动时自动执行RestTemplate传输</h3><p>之前有个需求，要求在服务启动的时候自动向配置文件中配置的几个服务地址下发数据，由于RestTemplate在这里是使用@AutoWired，所以为了实现这个功能，必须要在Spring容器整体加载完毕的时候才可以使用。<br>最初的时候我利用onApplicationEvent(ContextRefreshedEvent event)监听Spring加载完Context之后执行RestTemplate，结果会在执行RestTemplate传输数据时重复触发该事件，陷入死循环。<br>之后改用ApplicationReadyEvent，成功解决该问题，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceInitListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationReadyEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationReadyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ServiceHandler是我自己自定义的@Component</span></span><br><span class="line">        log.info(<span class="string">&quot;初始化引擎&quot;</span>);</span><br><span class="line">        ServiceHandler.initESPER();</span><br><span class="line">        log.info(<span class="string">&quot;开始策略下发&quot;</span>);</span><br><span class="line">        ServiceHandler.initPolicy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通过RestTemplate向Eureka注册的服务发送请求&quot;&gt;&lt;a href=&quot;#通过RestTemplate向Eureka注册的服务发送请求&quot; class=&quot;headerlink&quot; title=&quot;通过RestTemplate向Eureka注册的服务发送请求&quot;&gt;</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="http://voidbean.top/tags/SpringBoot/"/>
    
    <category term="RestTemplate" scheme="http://voidbean.top/tags/RestTemplate/"/>
    
    <category term="Eureka" scheme="http://voidbean.top/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch2.X与5.X中文分词插件IK配置详解</title>
    <link href="http://voidbean.top/2018/10/22/Elasticsearch2.X%20and%205.X%20IK/"/>
    <id>http://voidbean.top/2018/10/22/Elasticsearch2.X%20and%205.X%20IK/</id>
    <published>2018-10-22T01:29:37.000Z</published>
    <updated>2021-01-08T08:59:17.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-IK的安装与配置"><a href="#1-IK的安装与配置" class="headerlink" title="1.IK的安装与配置"></a>1.IK的安装与配置</h2><p>首先是安装,ES安装此处不再赘述,ES对应的版本号大致对比如下</p><table><thead><tr><th>IK version</th><th>ES version</th></tr></thead><tbody><tr><td>master</td><td>6.x -&gt; master</td></tr><tr><td>6.3.0</td><td>6.3.0</td></tr><tr><td>6.2.4</td><td>6.2.4</td></tr><tr><td>6.1.3</td><td>6.1.3</td></tr><tr><td>5.6.8</td><td>5.6.8</td></tr><tr><td>5.5.3</td><td>5.5.3</td></tr><tr><td>5.4.3</td><td>5.4.3</td></tr><tr><td>5.3.3</td><td>5.3.3</td></tr><tr><td>5.2.2</td><td>5.2.2</td></tr><tr><td>5.1.2</td><td>5.1.2</td></tr><tr><td>1.10.6</td><td>2.4.6</td></tr><tr><td>1.9.5</td><td>2.3.5</td></tr><tr><td>1.8.1</td><td>2.2.1</td></tr><tr><td>1.7.0</td><td>2.1.1</td></tr><tr><td>1.5.0</td><td>2.0.0</td></tr><tr><td>1.2.6</td><td>1.0.0</td></tr><tr><td>1.2.5</td><td>0.90.x</td></tr><tr><td>1.1.3</td><td>0.20.x</td></tr><tr><td>1.0.0</td><td>0.16.2 -&gt; 0.19.0</td></tr><tr><td>根据你的ES的具体版本寻找对应的IK版本</td><td></td></tr></tbody></table><blockquote><p>IK的github地址 <a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a><br>IK的编译后压缩包地址 <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a><br>注:如果你用的是源码需要手动用maven编译打包一下</p></blockquote><p>获取到压缩包后,扔到Elasticsearch&#x2F;plugins&#x2F;ik中进行解压(有的压缩包可能会自带一个父文件夹,那么就需要提取文件夹里面的东西扔到ik里),如果ES版本是2.X的，需要在conf&#x2F;elasticsearch.yml加入<code>index.analysis.analyzer.ik.type: ik</code>即可，如果是5.X版本的不需要进行任何的配置，直接启动elasticsearch，可以看到后台log里有写读取ik即为成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2018-10-11 15:13:19,285][INFO ][ik-analyzer              ] try load config from /home/es/es/elasticsearch-2.4.4/config/analysis-ik/IKAnalyzer.cfg.xml</span><br><span class="line">[2018-10-11 15:13:19,285][INFO ][ik-analyzer              ] try load config from /home/es/es/elasticsearch-2.4.4/plugins/ik/config/IKAnalyzer.cfg.xml</span><br></pre></td></tr></table></figure><h2 id="2-IK分词的原理与测试"><a href="#2-IK分词的原理与测试" class="headerlink" title="2.IK分词的原理与测试"></a>2.IK分词的原理与测试</h2><p>分词的测试使用curl或者postman都可以，我个人倾向于postman,主要是能保存，要方便一些。下面给出测试代码<br>首先是分词情况的测试</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9100</span>/_analyze</span><br><span class="line">JSON:&#123;</span><br><span class="line"><span class="attr">&quot;text&quot;</span>:<span class="string">&quot;今天也在摸鱼中度过&quot;</span>,</span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中analyzer里默认是standard,也可以指定其他的自带的分词器如english。ik的分词器有ik_max_word和ik_smart，二者区别前者为最细粒度的拆分，后者最粗粒度。<br>原本es对于中文的分词会把每一个字单独分开,在使用ik后会分成多个词，如果以最细粒度的ik_max_word拆分的话，结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;tokens&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;今天&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;start_offset&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;end_offset&quot;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;position&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;也&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;start_offset&quot;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">&quot;end_offset&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;CN_CHAR&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;position&quot;</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;摸鱼&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;start_offset&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">&quot;end_offset&quot;</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;position&quot;</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;摸&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;start_offset&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">&quot;end_offset&quot;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;position&quot;</span>: <span class="number">3</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;鱼&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;start_offset&quot;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">&quot;end_offset&quot;</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;CN_CHAR&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;position&quot;</span>: <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;中度&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;start_offset&quot;</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="attr">&quot;end_offset&quot;</span>: <span class="number">8</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;position&quot;</span>: <span class="number">5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;度过&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;start_offset&quot;</span>: <span class="number">7</span>,</span><br><span class="line">            <span class="attr">&quot;end_offset&quot;</span>: <span class="number">9</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;position&quot;</span>: <span class="number">6</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到除了拆分出常用词外，还删除了介词，以及拆分出单字也有意义的词，比如“摸”，”鱼“这类单独的动词或者名词。对于采用这类分词器的索引，在查询时如果输入”今“或者”天“这样的词是无法查询出对应的索引的，因为分词里没有包含这两个单字。如果输入”摸鱼“，”度过“这样分词的则可以查询出来。</p><p>值得一提的是，对于查询时的字符串也会进行一次分词，然后对这个分词与索引里的对应的字符串分词进行匹配，比如对于刚才的查询语句，输入“天”查不到任何东西，输入“也摸鱼”则可以查询出对应的索引。那么输入“天也摸鱼”时实际上也可以查询出对应的索引，原因就是对查询时的字符串分词后出现了”天“、”也“、”摸鱼“这三个词，进行匹配后返回了对应的索引。</p><h2 id="3-对索引指定分词器"><a href="#3-对索引指定分词器" class="headerlink" title="3.对索引指定分词器"></a>3.对索引指定分词器</h2><p>以上分区器就已经可以完全使用了，然而对于索引而言其默认分词器依然为standard,如果想让新的索引使用ik的话则必须要进行单独的配置。对此有两种方法，一种是只改对应的某几个索引的字段采取分词器，这种情况适用于多语言的索引，对每种语言单独配置分词器。另一种直接设置默认分词器，在设置之后，新加入的所有索引都会默认采用ik作为分词器，下面分别介绍两种的配置。</p><p>1）字段单独指定分词器<br>在建立索引时，比如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/testIndex/myType/_mapping</span><br><span class="line">JSON</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;myType&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;properties&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;tag&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;type&quot;</span>:<span class="string">&quot;string&quot;</span>,</span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中testIndex是索引名,myType是该索引的一个type名,tag是其中一个属性,执行该命令后tag这个属性的分词就会采用ik分词</p><p>不过要注意一点,对于已建好的属性是无法修改的，要想修改以前的属性只能重新建立索引导入原来的数据。<br>2）设置默认分词为ik<br>对于2.X版本中可以直接在对应的elasticsearch.yml里进行如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index.analysis.analyzer.default.type: ik</span><br><span class="line">#如果修改后启动报错请检查ik名是否跟你之前配置的ik名称一致</span><br></pre></td></tr></table></figure><p>之后所有新的索引都会自动配置为ik作为分词器，然而跟上面的方法一样，都无法让之前的数据使用ik分词，依然只能重新导入。</p><p>对于5.X版本不支持yml配置，启动时会直接告诉你请采用curl修改setting配置来实现默认ik的分词（这种方式对2.X版本依然有效）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUT http:<span class="comment">//10.88.2.119:9200/indexName/</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;default&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;ik&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺带一提对于setting的配置可以随时更改，无需新建新的索引，代码如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>/indexName/_settings</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;default&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;standard&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果报错提示index已存在，需要在修改settings之前，执行<code>POST 127.0.0.1:9200/indexName/_close</code>关闭索引,然后执行完修改settings之后,再执行<code>POST 127.0.0.1:9200/indexName/_open</code>打开索引即可。</p><h2 id="4-配置英文词过滤"><a href="#4-配置英文词过滤" class="headerlink" title="4.配置英文词过滤"></a>4.配置英文词过滤</h2><p>以上已经完成了所需的中文分词功能，这里单独提到的英文词过滤是因为ik对于英文分词仅限于根据空格等分隔符来区分出单词来，然后转化为小写，而没有进行进一步的筛选，比如对于english分词器，对于“He likes she”,会拆分成”he”,”like”,”she”，注意这里拆分出来的是”like“而不是”likes”。然而使用ik分词，则会出现”he”,”likes”,”she”，这就意味着查询时输入like是查询不出这条语句的，必须查询likes。为了解决这个问题，我采用的是</p><blockquote><p><a href="http://www.360doc.com/content/16/1017/14/29098895_599094191.shtml">http://www.360doc.com/content/16/1017/14/29098895_599094191.shtml</a></p></blockquote><p>提到的将中文分词与英文过滤混合的方式，配置时如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index:</span> </span><br><span class="line"> <span class="attr">analysis:</span> </span><br><span class="line">  <span class="attr">analyzer:</span> </span><br><span class="line">   <span class="attr">default:</span></span><br><span class="line">     <span class="attr">type:</span> <span class="string">custom</span></span><br><span class="line">     <span class="attr">tokenizer:</span> <span class="string">ik</span></span><br><span class="line">     <span class="attr">filter:</span> [<span class="string">&quot;stemmer&quot;</span>]</span><br></pre></td></tr></table></figure><p>当然写成</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index.analysis.analyzer.default.type:</span> <span class="string">custom</span></span><br><span class="line"><span class="attr">index.analysis.analyzer.default.tokenizer:</span> <span class="string">ik</span></span><br><span class="line"><span class="attr">index.analysis.analyzer.default.filter:</span> [<span class="string">&quot;stemmer&quot;</span>]</span><br></pre></td></tr></table></figure><p>也是没问题的，不过我喜欢前一种方法，看起来更直观一些。</p><p>如果使用settings</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;default&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;custom&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;tokenizer&quot;</span>:<span class="string">&quot;ik&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>:[<span class="string">&quot;stemmer&quot;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在进行这样的配置之后ik的分词对于加了s之类的单词也能正确分词了~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是ES的中文分词的配置，其实弄懂了还是很简单的，只不过2.X版本跳到5.X版本是真的坑，总会出现一些莫名其妙的错误，顺带吐槽一下5.X不支持yml配置默认分词器好坑啊，每次建立索引的时候要记得加上默认分词器的配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-IK的安装与配置&quot;&gt;&lt;a href=&quot;#1-IK的安装与配置&quot; class=&quot;headerlink&quot; title=&quot;1.IK的安装与配置&quot;&gt;&lt;/a&gt;1.IK的安装与配置&lt;/h2&gt;&lt;p&gt;首先是安装,ES安装此处不再赘述,ES对应的版本号大致对比如下&lt;/p&gt;
&lt;t</summary>
      
    
    
    
    
    <category term="elasticsearch" scheme="http://voidbean.top/tags/elasticsearch/"/>
    
    <category term="中文分词" scheme="http://voidbean.top/tags/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://voidbean.top/2018/10/09/git%20command%20help/"/>
    <id>http://voidbean.top/2018/10/09/git%20command%20help/</id>
    <published>2018-10-09T01:29:37.000Z</published>
    <updated>2022-01-30T02:56:48.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><p>1.远程分支关联 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git地址</span><br></pre></td></tr></table></figure><p>2.获取本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>区别:pull相当于fetch+merge,所以fetch更安全一点,pull更方便一点<br>3.推送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>4.只删除远程分支上内容,不删除本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .idea  #--cached不会把本地的.idea删除</span><br><span class="line">git commit -m &#x27;delete .idea dir&#x27;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>5.查看用户名、邮箱并设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br><span class="line">git config --global user.name 新名字</span><br><span class="line">git config --global user.email 新邮箱</span><br></pre></td></tr></table></figure><p>6.pull分支,对冲突合并</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash #暂存了本地的修改</span><br><span class="line">git pull #获取远程内容到本地</span><br><span class="line">git stash list #查看stash的全部信息</span><br><span class="line">git stash pop stash的id  #恢复指定id的stash快照</span><br></pre></td></tr></table></figure><p>之后文件会自动标记冲突位置,修改后提交即可<br>(这个冲突一定要注意看好,git的标记的冲突位置是直接在源码里标记的,如果不修改绝对报错,坑的一批)</p><p>7.新建分支,合并分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch newBranch001</span><br><span class="line">git checkout newBranch001</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b newBranch001</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git常用命令&quot;&gt;&lt;a href=&quot;#git常用命令&quot; class=&quot;headerlink&quot; title=&quot;git常用命令&quot;&gt;&lt;/a&gt;git常用命令&lt;/h1&gt;&lt;p&gt;1.远程分支关联 &lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;tab</summary>
      
    
    
    
    
    <category term="git" scheme="http://voidbean.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>ES配置常见问题</title>
    <link href="http://voidbean.top/2018/09/18/ES%20QA/"/>
    <id>http://voidbean.top/2018/09/18/ES%20QA/</id>
    <published>2018-09-18T01:29:37.000Z</published>
    <updated>2021-01-08T08:59:17.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES配置常见问题"><a href="#ES配置常见问题" class="headerlink" title="ES配置常见问题"></a>ES配置常见问题</h3><p>按着网上的乱七八糟的各种配制方法配置ES，结果启动的时候报了自检失败的错误</p><blockquote><p>ERROR: [X] bootstrap checks failed</p></blockquote><p>这些错误都是因为某项检查自检没有通过而报的错，我自己的虚拟机出现的错误如下：</p><h4 id="1-“for-elasticsearch-process-is-too-low-increase-to-at-least-65536-”"><a href="#1-“for-elasticsearch-process-is-too-low-increase-to-at-least-65536-”" class="headerlink" title="1 “for elasticsearch process is too low, increase to at least [65536]”"></a>1 “for elasticsearch process is too low, increase to at least [65536]”</h4><p>原因：启动ES的用户权限过低，需要提升到65536。<br>解决方法：使用root用户，进入&#x2F;etc&#x2F;security&#x2F;limits.conf，在最后加入<code>你的用户名 soft nofile 65536</code>和<code>你的用户名 hard nofile 65536</code>。保存后执行<code>sysctl -p</code>，重新启动ES即可。</p><h4 id="2-“system-call-filters-failed-to-install-check-the-logs-and-fix-your-configuration-or-disable-system-call-filters-at-your-own-risk”"><a href="#2-“system-call-filters-failed-to-install-check-the-logs-and-fix-your-configuration-or-disable-system-call-filters-at-your-own-risk”" class="headerlink" title="2 “system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk”"></a>2 “system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk”</h4><p>原因：Centos6不支持SeeComp，ES执行时进行检测，检测失败无法启动。<br>解决方法：修改conf&#x2F;elasticsearch.yml，修改或者加入如下两条</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">bootstrap.system_call_filter:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="3-“max-number-of-threads-is-too-low-increase-to-at-least-4096-；”"><a href="#3-“max-number-of-threads-is-too-low-increase-to-at-least-4096-；”" class="headerlink" title="3 “max number of threads is too low, increase to at least [4096]；”"></a>3 “max number of threads is too low, increase to at least [4096]；”</h4><p>原因：当前用户最大线程数太低，需要提升到4096以上。<br>解决方法：进入&#x2F;etc&#x2F;security&#x2F;limit.d&#x2F;20-nproc.conf（可能不是20-xxx.conf，我的是90-nproc.conf），在里面加入<code>* soft nproc 4096</code>(“ * “可以为指定的用户名)，重启后可以用<code>ulimit -a</code>来查看线程是否改为4096。</p><h4 id="4-“max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least-262144-”"><a href="#4-“max-virtual-memory-areas-vm-max-map-count-65530-is-too-low-increase-to-at-least-262144-”" class="headerlink" title="4 “max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]”"></a>4 “max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]”</h4><p>原因：最大虚拟内存过小，需要提升到262144以上。<br>解决方法：进入&#x2F;etc&#x2F;sysctl.conf ，加入<code>vm.max_map_count=262144</code>，然后执行sysctl -p即可。</p><p>PS：ES要求的东西真多，挨个修改了这堆问题终于是能跑起来了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ES配置常见问题&quot;&gt;&lt;a href=&quot;#ES配置常见问题&quot; class=&quot;headerlink&quot; title=&quot;ES配置常见问题&quot;&gt;&lt;/a&gt;ES配置常见问题&lt;/h3&gt;&lt;p&gt;按着网上的乱七八糟的各种配制方法配置ES，结果启动的时候报了自检失败的错误&lt;/p&gt;
&lt;blo</summary>
      
    
    
    
    
    <category term="elasticsearch" scheme="http://voidbean.top/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis通过ResultMap实现关联查询</title>
    <link href="http://voidbean.top/2018/09/03/Mybatis%20Search%20By%20ResultMap/"/>
    <id>http://voidbean.top/2018/09/03/Mybatis%20Search%20By%20ResultMap/</id>
    <published>2018-09-03T06:02:37.000Z</published>
    <updated>2021-01-08T08:59:17.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis通过ResultMap实现关联查询"><a href="#Mybatis通过ResultMap实现关联查询" class="headerlink" title="Mybatis通过ResultMap实现关联查询"></a>Mybatis通过ResultMap实现关联查询</h1><p>本文主要讲通过以resultmap为主实现mybatis一对一、一对多的关联查询的两种方式。</p><h3 id="实体类关系"><a href="#实体类关系" class="headerlink" title="实体类关系"></a>实体类关系</h3><p>用户类(User)与用户组别类(Group)，关系为一对一。<br>用户类(User)与邮件类(Mail),关系为一对多。<br>即每个用户有一个自己归属的组别，同时这个用户手里也有多条接收到的邮件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">User&#123;</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPass;</span><br><span class="line">    <span class="keyword">private</span> Long groupId;</span><br><span class="line">&#125;</span><br><span class="line">Group&#123;</span><br><span class="line">    <span class="keyword">private</span> Long groupId;</span><br><span class="line">    <span class="keyword">private</span> String groupName;</span><br><span class="line">&#125;</span><br><span class="line">Mail&#123;</span><br><span class="line">    <span class="keyword">private</span> Long mailId;</span><br><span class="line">    <span class="keyword">private</span> Long userId;<span class="comment">//邮件通过userId来进行关联查询</span></span><br><span class="line">    <span class="keyword">private</span> String recipient;</span><br><span class="line">    <span class="keyword">private</span> String sender;</span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、通过join进行sql的连接查询"><a href="#1、通过join进行sql的连接查询" class="headerlink" title="1、通过join进行sql的连接查询"></a>1、通过join进行sql的连接查询</h3><p>首先写对应的select查询语句，以左连接的方式查询出对应的Group信息和Mail信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserWithAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserWithAll&quot;</span>&gt;</span></span><br><span class="line">    select u.*,g.*,m.* from User u</span><br><span class="line">    left join Group g on g.groupId = u.groupId</span><br><span class="line">    left join Mail m on m.user = u.userId</span><br><span class="line">    where u.userId = #&#123;userId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>于是在执行该方法时，mybatis会依照该sql语句查询出对应的用户的用户信息、组别信息和邮件信息，并将该信息存入UserWithAll这个resultMap指向的实体类。为了接收这些信息，需要新建一个实体类UserWithAll，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserWithAll extends User&#123;</span><br><span class="line">    <span class="keyword">private</span> Group group;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Mail&gt; mail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有了对应的储存位置后，配置resultMap的映射关系，其映射关系为将select查询结果映射至UserWithAll这个实体类中，具体如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserWtihAll&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.test.model.entity.UserWithAll&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userPass&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_pass&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;groupID&quot;</span> <span class="attr">column</span>=<span class="string">&quot;group_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;group&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.test.model.entity.Group&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">&quot;com.test.repository.mybatis.UserMapper.Group&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;mail&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.test.model.entity.Mail&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">&quot;com.test.repository.mybatis.UserMapper.Mail&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的配置中，association和collection分别对应一对一查询和一对多查询，这两个对应新的resultMap来实现相应的映射，要注意的是association不能接收多条数据，否则会报错。下面分别对这两个来写映射关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;group&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.test.model.entity.Group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;groupId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;group_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;groupName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;group_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;mail&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.test.model.entity.Mail&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;mailId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;mail_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;recipient&quot;</span> <span class="attr">column</span>=<span class="string">&quot;recipient&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sender&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sender&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;detail&quot;</span> <span class="attr">column</span>=<span class="string">&quot;detail&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在完成以上内容后，在DAO层用<code>List&lt;UserWithAll&gt; selectUserWithAll()</code>方法即可获取到对应的关联查询结果。</p><h3 id="2、通过嵌套的select查询实现关联查询"><a href="#2、通过嵌套的select查询实现关联查询" class="headerlink" title="2、通过嵌套的select查询实现关联查询"></a>2、通过嵌套的select查询实现关联查询</h3><p>该方法相比其连接查询而言效率更高，同时由于可以自定义select查询，比起连接查询也要更灵活一些。首先依旧是先配置UserWithAll的resultMap，区别在于<code>&lt;association/&gt;&lt;collection/&gt;</code>这两个标签，需要配置这两个要执行的select方法以及传入的参数名，具体如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserWtihAll&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.test.model.entity.UserWithAll&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userPass&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_pass&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;groupID&quot;</span> <span class="attr">column</span>=<span class="string">&quot;group_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;group&quot;</span> <span class="attr">column</span>=<span class="string">&quot;group_id&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">select</span>=<span class="string">&quot;com.test.repository.mybatis.UserMapper.selectGroupById&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;mail&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">select</span>=<span class="string">&quot;com.test.repository.mybatis.UserMapper.selectMailByUserId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里<code>&lt;association/&gt;</code>中的property指的是返回到UserWithAll时对应的属性，column指的是将数据库中哪个字段传入该select方法，select指的是调用哪里的select方法，这里select的路径也可以改为其他Mapper文件里的select方法，比如说是你的参数表映射文件ParamMapper，那么这里的为<code>select=&quot;com.test.repository.mybatis.ParamMapper.selectMailByUserId</code>。在完成这部分后在写对应的select方法及对应的resultMap，如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;group&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.test.model.entity.Group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;groupId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;group_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;groupName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;group_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectGroupById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;Group&quot;</span>&gt;</span></span><br><span class="line">select * from Group where group_id=#&#123;group_id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样的Mail的resultMap与select也跟这个一样，不再赘述。经过以上配置后，在执行相应的如<code>List&lt;UserWithAll&gt; selectUserWithAll()</code>这样的方法时，会自动执行Group与Mail的select方法，然后通过resultMap映射至UserWithAll实体类中的group与mail中。</p><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>这两种方法都可以实现表关联查询，区别在于一种关联查询是通过数据库的sql语句直接获取相应的信息，另一种则是通过resultMap先执行关联的查询，将结果映射回本身的resultMap。两者比较起来的话，前者书写简单，只要配一个resultMap以及在select里加上left join一类的关键字就可以，但执行效率不高，特别是在没有给外键建立索引且数据量较大的情况下，这种方法耗费时长可以说是令人发指。后者书写要稍微麻烦一点，一个是除了要配置resultMap外，还要单独写一份sql语句，但是效率要远高于前者。所以如果是小量数据的关联查询用left join无可厚非，如果数据量大的话尽量使用后者这种方式。顺带一提这两个方式也是可以结合使用的，比如A、B、C三张表关联查询，其中AB数据量较大，C只是A表的一张参数表，那么可以给A和B使用后者那种方法，以A为基础建立resultMap，加入<code>&lt;association property=&quot;B&quot; column=&quot;A.id&quot; select=&quot;selectB&quot;/&gt;</code>或者<code>&lt;collection  property=&quot;B&quot; column=&quot;A.id&quot; select=&quot;selectB&quot;/&gt;</code>进行关联的查询，然后在这个resultMap里加一个<code>&lt;association property=&quot;C&quot; javaType=&quot;xx.xx.C&quot; resultMap=&quot;xx.xx.C&quot;/&gt;</code>指向C的resultMap，在查询语句里left join C表即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mybatis通过ResultMap实现关联查询&quot;&gt;&lt;a href=&quot;#Mybatis通过ResultMap实现关联查询&quot; class=&quot;headerlink&quot; title=&quot;Mybatis通过ResultMap实现关联查询&quot;&gt;&lt;/a&gt;Mybatis通过Resul</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="http://voidbean.top/tags/SpringBoot/"/>
    
    <category term="MyBatis" scheme="http://voidbean.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>nginx如何解决跨域问题</title>
    <link href="http://voidbean.top/2018/08/30/nginx%20kuayu/"/>
    <id>http://voidbean.top/2018/08/30/nginx%20kuayu/</id>
    <published>2018-08-30T05:29:37.000Z</published>
    <updated>2021-01-08T08:59:17.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx解决跨域原理及相关配置"><a href="#nginx解决跨域原理及相关配置" class="headerlink" title="nginx解决跨域原理及相关配置"></a>nginx解决跨域原理及相关配置</h1><h3 id="1、什么是跨域"><a href="#1、什么是跨域" class="headerlink" title="1、什么是跨域"></a>1、什么是跨域</h3><p>从某一个域请求其他域的各类资源，其中只要两个地址的域名、端口以及协议有不同的地方就会视为跨域，跨域资源无法直接获取。<br>比如：<br>域名不同  www.<strong>a</strong>.com&#x2F;1.html 请求 www.<strong>b</strong>.com&#x2F;1.js<br>端口不同  <a href="http://www.a.com:**8000**/1.html">www.a.com:**8000**/1.html</a> 请求 <a href="http://www.a.com:**8001**/1.js">www.a.com:**8001**/1.js</a><br>协议不同  <strong>http</strong>:&#x2F;&#x2F;<a href="http://www.a.com/1.html">www.a.com/1.html</a> 请求 <strong>https</strong>:&#x2F;&#x2F;<a href="http://www.a.com/1.html">www.a.com/1.html</a> </p><h3 id="2、nginx如何解决跨域问题"><a href="#2、nginx如何解决跨域问题" class="headerlink" title="2、nginx如何解决跨域问题"></a>2、nginx如何解决跨域问题</h3><p>拿上面的来举例，a网站向b网站请求1.js文件时，向b网站发送一个获取的请求，nginx根据配置文件接收这个请求，代替a网站向b网站来请求这个资源，nginx拿到这个资源后再返回给a网站，以此来解决了跨域问题。</p><h3 id="3、nginx配置"><a href="#3、nginx配置" class="headerlink" title="3、nginx配置"></a>3、nginx配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">  #监听8000端口</span><br><span class="line">        listen       8000;</span><br><span class="line">        #监听指定的ip地址</span><br><span class="line">        server_name  10.10.2.116;</span><br><span class="line">        #对对应url路径执行反向代理,如10.10.2.116:8000/demo</span><br><span class="line">        location /demo &#123;</span><br><span class="line">        #目标的ip地址</span><br><span class="line">            proxy_pass http://10.10.2.116:10037; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过此配置可以实现访问10.10.2.116的8000端口来获取同ip下10037端口下的相应资源</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;nginx解决跨域原理及相关配置&quot;&gt;&lt;a href=&quot;#nginx解决跨域原理及相关配置&quot; class=&quot;headerlink&quot; title=&quot;nginx解决跨域原理及相关配置&quot;&gt;&lt;/a&gt;nginx解决跨域原理及相关配置&lt;/h1&gt;&lt;h3 id=&quot;1、什么是跨域&quot;&gt;</summary>
      
    
    
    
    
    <category term="nginx" scheme="http://voidbean.top/tags/nginx/"/>
    
  </entry>
  
</feed>
